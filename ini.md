# 项目开发文档 (ini.md) 

## 前言

我已经完成了本项目的核心架构设计、数据模型定义以及初步的数据同步与计算实现。我们正处于从后端逻辑开发过渡到前端交互完善的关键阶段。

你的首要任务是，严格以这份文档中描述的业务逻辑和已确认的代码结构为基础，继续完成后续的开发工作。 这份文档经过了最终审查，修正了之前所有已知的错误和不一致之处，是你可以完全信赖的、唯一的真相来源。

---
## 新需求：

1. 对于系统在核算账单时自动添加的”财务调整项“：`退客户款[系统添加] 保证金退款` 	要针对这一”退款项“增加一个”转移“功能。业务上有一个需求，当客户第一个合同结束，新签第二个合同时，这个保证金有些时候无需退给客户，而是转移到新合同中，并且要在新合同中增加一个”财务调整项“： `退客户款 [系统添加] 其他合同转移保证金退款`	并且点击”其他合同“字样可以在新窗口打开查看相应的合同。便于运营人员知道这比退款从何处转移。同时，在计算客户应付款时，也要减去此笔退款。[已完成]

2. 创建虚拟合同：由于有些特殊客户不签合同，在”金数据“平台中就没有合同，因此我们的项目也无法产生账单。此时就需要运营人员可以在”合同管理“中”新增虚拟合同“，包含合同的必要字段：客户名称、客户联系人、员工名称（可以通过拼音从现有用户、客户中选择，如果没有则新增客户或员工，此处与同步合同时查找/新建用户逻辑一致）、级别、保证金、介绍费、管理费、合同开始日期、合同结束日期、是否自动续签、合同类型（月嫂/育儿嫂/育儿嫂试工）、备注等必要字段。[已完成]

3. 打款/付款记录中可以上传图片（拖拽的方式）

   1. 订单详情[已完成]
   2. 列表批量收付款

4. 如果客户联系人不为空，在客户名称处优先显示客户联系人。

5. 终止合同要有一个“终止日”而不是修改原合同的合同结束日。[已完成]

6. 萌嫂扣款，也要支持“转移到下个月”账单中。[已完成]

   1. 员工反给公司的 10% 应该作为“财务调整项”，便于运营人员管理此款项是否已收到[已完成]
   2. 对于公司反给公司的10% 要判断一下，如果员工与此客户已经签订过合同，产生过服务则不产生这条返给公司的10%。[已完成]

7. 转移保证金后要显示转移到哪个账单，显示账单链接，点击后跳转到相应的账单查看。[已完成]

8. 款项往来明细：

   1. 客户给公司的（客户付款）：管理费+保证金+介绍费+押金 [已完成]
   2. 客户给员工的（员工领款）：总劳务费 + 增款-客户扣款[已完成]
   3. 员工给公司的（员工付款）：10%返款、公司扣款[已完成]

   这些明细要体现“结算过程”：是否打款、打款时间、渠道&备注。萌嫂减款需要区分“客户减款”、“公司减款”。[已完成]

   在账单列表，现有的"本月应收/应付"中增加一行体现“员工付款”总金额，在进行批量结算时也增加一列，用来处理"员工付款"情况[已完成]按“缴”显示

9. 如果增加新的“财务调整项”，则需要重新计算“支付状态”/"付款状态"。因为“待付/待收余额”一定会发生变换从而影响现在的“收付款状态[已完成]

10. 增加”删除合同“的功能，对于手动添加的虚拟合同，可以手动删除，删除时删除所有调整项、日志、账单

11. 可修改合同的”是否自动续签“的值：[已完成]

    1. 如果当前状态时”否“，改为”是“，则触发自动延展账单的功能
    2. 如果当前是”是“，改为”否“，则需要确认合同终止日期，确认后，相当于触发”终止合同“的功能，并触发相应的账单重算

12. 替班需要增加一个替班业务细分

    1. 目前的替班都是在现有合同内进行替班，即：对本公司的员工进行替班 [已完成]
    2. 有一种替班业务情况是“替非本公司员工“的班，因此这种替班是没有”现有合同“的，这种要在现在的系统上如何处理？添加一个替班合同？这种替班有以下规则：
       1. 按天收管理费，替几天收几天的管理费。管理费率默认是20%。[已完成]
       2. 替班开始、结束时间精确到小时、分钟（仍然是以半小时为步长，此处操作与现有替班时间一样）[已完成]
       3. 替班账单支持延长服务期【取消此需求】
    
13. 日志功能被遗失了，用户进入“编辑模式”后的所有修改，都没有日志记录了，这部分功能缺失了，需要恢复。[已完成]

14. 需要一个为指定合同重新生成所有账单的功能。

15. 创建外公司替班合同并创建账单时，也要按正常周期来计算管理费，并按自然月生成账单。目前系统对于跨月大于30天的合同只是生成了1个大账单，这样管理费就只能按30天收了。应该按自然月整月来生成账单。————仍然保留是也给大账单，在最后一起结账，只要管理费准确就行。[已完成]

16. 在计算育儿嫂“非月签”账单管理费的时候，对于3月21日到8月21日这种合同，在计算管理费时按5个整月计算，而不是首月10天（30-21），尾月21天这样来计算。[已完成]

17. 发票管理可以在”非编辑模式“下进行 [已完成]

18. 在账单列表中增加一个”客户付款进度“，通过一个很mini的liner来显示，放在”本月应付/应收“列，体现在”客应付款”上面一个小的liner，通过颜色来标示“客户已付款与客户应付款的占比”，鼠标放在liner上可以看到具体的“客户已付款”。客户已付款记录从账单详情中的“实付总额”中读取。只有在实付总额>0时才显示这个mini liner [已完成]

19. 在合同中增加"介绍费"后,介绍费要作为"财务调整项"自动显示在账单中,只能转移,不能删除.[已完成]

20. 月嫂合同中都会有”定金“金额统一为3000，由于月嫂合同签订后会先收订金，但是没有账单，需要一个地方记录”订金“的收取记录。此处需要设计一下实现方式[已完成]

21. 在每月账单的页面有一个"本月管理费总计"，这里需要新增加一个"本月应收款总计"的汇总显示以及新导出功能包括以下款项：[已完成]
    1. 定金+介绍费+管理费+客户增款+保证金+员工应缴款(萌嫂减款).也支持导出,导出后这几个款项分别在不同列显示;其中"定金"来自月嫂合同,这个金额并没有直接出现在"账单"中,因为月嫂合同是先交定金,此时没有账单.只有确认了实际上户日期才会生成账单,并将"定金"附加到账单中.为了保持业务一致性,此处仍然从已经附加到账单的"财务调整项"中获取定金,如果没有账单,则不计算定金.“保证金”通过financial_adjustments中的description中的“保证金”字样来区分，注意在同一个账单的财务调整项中又是会有”保证金、保证金退款“，在计算此账单”保证金“时，保证金 = 保证金 - 保证金退款。[已完成]
    2. 现有的"本月管理费总计"中需要增加"员工应缴款（萌嫂减款），导出也要增加此列.[已完成]
    
22. 月嫂合同列表中要体现“定金”是否已支付。首页仪表盘中增加一个待办提醒“待收定金“。[已完成]

23. 健壮性优化，在 AdjustmentType 这个枚举里，增加一个 SECURITY_DEPOSIT 类型，就像DEPOSIT 一样。这样代码会更健壮、更清晰。同时修改所有“保证金“处理环节。 ——暂缓
    1. 添加保证金  _handle_security_deposit 
    2. 退还保证金
    3. 计算客户应付款 / 本月应收款总计
    
24. 对于仪表盘中的应收款统计需要重新整理一下，管理费、介绍费、员工首月10%（此款项需要一个单独的财务调整项类型）[已完成]

25. 试工成功后，运营人员会创建一个新的育儿嫂合同，试工合同需要与次正式育儿嫂合同关联，将员工工资转到正式合同中进行支付。
    试工后要确认试工完成 或 试工失败
    试工完成，将次试工合同关联到对应的月嫂合同中，点击完成，选择此客户的后续合同，如果没有关联合同无法自动完成
        育儿嫂账单中增加显示试工合同产生的介绍费，试工产生的员工费用都要转入到育儿嫂正式账单的第一个月账单中。
    
26. 替班合同前台增加互斥逻辑，介绍费与管理费只能输入一个。[已完成]

27. 在试工合同试工成功，并将试工费用转入到正式合同首期账单是，试工费用会显示在财务调整项中。此时需要显示此财务调整项的”计算过程“：试工工资 = 试工日薪*试工天数（试工开始日~试工结束日）

28. 试工合同列表也要有试工成功、试工失败的按钮，便于操作。试工成功转入正式合同时，需要显示账单转入明细，例如”介绍费“、"试工费”、“管理费”，将这些非零的费用显示出来告知用户，这些费用将要转入到正式合同首期账单中。[已完成]

29. 创建试工合同时候，管理费是按比例的不是一个确切的金额数字，要根据试工结束（失败或成功）时按管理费率计算得出管理费，前台选取管理费比例，默认20%，可以人工修改。仍然保留管理费和介绍费互斥的逻辑，选择了管理费费率就不可以填写介绍费了。[已完成]

30. 替班合同的费用也需要可以转到正式合同中。应对场景：替班员工很优秀，要终止现在的合同，并签署新合同。然后将替班的所有费用，例如管理费、加班费、劳务费 转到新的正式合同的首期账单中。[已完成]

31. 转移管理费的时候，默认是同客户转移，有一个开关“查看所有合同”点击后可以按客户、员工来检索所有合同，并列出合同周期，便于运营人员将保证金转个另一个合同（同一个家庭可能是父亲签署第一个合同，后续第二个合同可能是母亲）

32. 退还管理费：最后一个月退还时，按“未发生”天数退还管理费，而不是“本月管理费 - 已发生天数管理费”。无论如何，账单中初始的“本月交管理费”都不应该变化，只能通过“财务调整项”退款来退还管理费。[已完成]

33. BUG 合同详情中的，是否自动续签开关没有正确显示，始终是关闭的。[已完成]

34. 右侧工资单中，在添加”记录工资发放“时，如果勾选了”公司代付“，实际上是从 退客户管理费 中扣除的”员工工资“，因此对于客户账单中”退还的管理费“而言，需要扣除这部分”公司代付“的工资，因此，此时在客户账单中就应该出现一笔财务调整项，客户增款：公司代付员工工资[已完成]

35. 新增虚拟合同的时候，在”育儿嫂合同“类型中，将”是否自动续签“的选项向上挪动，放到合同开始日期前方，如果打开了此开关，则填写完合同开始日期后，合同结束日期自动变为合同开始月对应的月底最后一天。因为系统会将后续月份自动续签并生成整月账单。[已完成]

36. 相同客户相同员工续约问题，账单要合并？【已设计，具体看 docs/monthly_statement_design.md 中的文件[已完成]
    做了一半没做下去，具体见本地 feature/monthly-statement 分支开发。

37. 客户账单与员工工资单，中要有一个复制功能，复制客户应缴款明细，应付款员工款明细[已完成]

38. BUG 小数点问题，实际劳务天数支持输入小数点后3位，但是计算过程中仍然是2位，导致最后就算以及写入计算日志中的数据和运营人员手动计算的有偏差。[已完成]

39. 业务人员每月或每周会导出银行回单，其中有付款人、付款金额，根据这个自动将回款金额对应到相应的客户对账单statment 中，用来计算客户已打款、打款金额等。同时要关联此回单的”交易流水号“，系统也要保存此交易流水号。由于一个银行回单中很多笔费用，要逐笔对应到相应的订单中，对于没有对应上的要显示出来，便于提醒财务人员。而且一个月可能会导出多次银行回单，在匹配回款是要排除重复，不能同一笔费用导入多次就记录多次回款。会有固定格式：[已完成]
交易流水号	打印实例号	登记时间	交易方式	交易币种	交易金额	收(付)方账号	收(付)方名称	摘要	业务类型	打印状态	操作 
C04477K000D4O1Z	679B656780170	2025-08-01 09:18:48	入账	人民币	1800	121945846210806	上海玥来越好文化传媒工作室	7+8月服务费	汇入汇款	已打印	- 
C04477M000UN2GZ	679B246812108	2025-08-03 15:04:23	入账	人民币	700	6217000010037468660	马原野	-	汇入汇款（网银互联）	已打印	- 
    通过本地 feature/auto-match-bank-statement 分支开发
    已完成设计文档 docs/bank_statement_reconciliation_design.md

## bug：
1. 查看账单时没有客户id，无法点击合同详情[已完成]

## 优化：
1. 待手动分配、待确认等页签也要增加“查看账单”的功能，与“已确认”页签一致。[已完成]


40. 在合同终止时要选一个具体终止下户的时间点，超过中午12点，在计算管理费退款的时候，退管理费天数 = 合同结束日 - 终止日；如果早于中午12点，退管理费天数 = 合同结束日 - 合同终止日 +1；同时，在选择时间后，页面会提示”预计按x天退还本月管理费“。【改为其他需求，终止合同时人工选择是否计算终止日的管理费】[已完成]

41. 不仅要导入客户回款的对账，也要有一个公司付款的对账，公司付给员工的费用时，也要有付款对账。[已完成]

42. **关键问题** 没有客户ID，需要创建一个客户表，存储客户信息以及客户ID？？？

43. 根据收款分配的功能，完成相似的”付款分配“来为员工进行付款，此处关联的就是”员工名称“了[已完成]

44. 忽略某回款时应该写一个备注，便于查看[已完成]

45. 要汇总回款总额，已分配总额、未分配金额、已忽略金额[已完成]

46. 未匹配的银行流水，在搜索时支持搜索员工姓名，并找出此员工在当前月份的账单[已完成]

47. 增加一个页面，放在"银行对账中心“菜单下，用来查看导入的所有回款流水数据，按月查看，并可点击查看每一笔回款的分配情况。只是按流水号、打款人、备注、回款状态进行检索[已完成]

48. ”忽略“时增加一个复选框”永久忽略“，以后在出现这个付款人或收款人时，自动进入到”已忽略“状态，并且忽略原因为”{首次忽略原因}(永久忽略)“。[已完成]

49. bug，在试工合同转正式合同时，要考虑”试工期“与正式合同期重合的问题。如果重合，则代表新合同已经包含试工期间的工资，就不再转移试工合同工资到新合同的财务调整项中。如果不包含，才需要转移，如果部分包含，则转移非重合部分的试工工资。[已完成]

50. bug. 生产环境 5e071db5-5d28-45ad-9c85-12488a37d3d4 合同账单多退了1天管理费。合同在9月9日开始，9月30日到期，级别是7000的育儿嫂合同，实际劳务天数21天没错。用户手动操作了“终止合同“终止日期也是9月30日，但是却产生了一天管理费的退款。请找到这个原因并修复。因为合同虽然人工点击了终止，但终止日期就是合同结束日期，因此不需要退管理费[已完成]

51. 一般情况下，替班时不会产生替班管理费（此处替班指的是在现有合同中进行替班，而非“外部替班合同”）。但是以下两种情况要产生替班管理费：[已完成]
    1. 在添加替班记录时，如果此时合同已经结束，则需要在替班账单中体现替班管理费。按替班人员级别进行计算。
    2. 同样，在终止合同的时候，如果终止日期之后还有替班记录，此时也会产生替班管理费，
    替班管理费天数 = 替班时间段与合同非重合部分

52. 继续优化客户银行回款流水的分配，使其更加操作合理和自动化

53. 对系统增加一个问答小秘书，可以基于数据库调用所有api进行查询

54. 替班记录表增加管理费率字段，让月嫂育儿嫂的管理费 管理费率分别保存。添加替班记录时，育儿嫂类型的也要显示”管理费率“的输入框，输入框有以下限制：[已完成]
    如果当前替班结束时间 大于 max(合同终止日,合同到期结束日)，则默认值为10%，并可以修改。否则管理费率为0，且输入框为只读。
    注意修改：
    _calculate_substitute_details ()中月嫂获取管理费率逻辑，并且对于育儿嫂也要显示替班管理费率（现在是0，写死的，也是在这个函数中国）
    if substitute_type == "maternity_nurse":
            management_fee_rate = D(sub_record.substitute_management_fee)
            customer_daily_rate = (
                substitute_level * (D(1) - management_fee_rate) / D(26)
            )

55. 替班工资目前是都会变为一条财务调整项“公司代付工资"放在客户账单中，但实际上对于替班类型为”月嫂“或”育儿嫂“是有区别的，类型为育儿嫂的保持现状没有问题。但类型为”月嫂“的，不需要产生此财务调整项，客户需要直接将此月嫂替班的劳务费直接付给员工，另外单独将月嫂替班产生的管理费付给公司 [已完成]

56. 育儿嫂合同到期或手动终止的时候：
    1. 最后一个月的员工工资是由公司代付的，因此客户账单中应该自动出现一个财务调整项”公司代付员工工资“
    2. 客户账单中的”总应付款“可以转移到其他合同，例如合同A的最后一个月8月账单有-1000的 总应付款 (即，需要退还给客户的费用)，为了方便财务记账，可以转移到相同客户的其他合同B首月账单中，通过财务调整项的方式出现一笔”旧合同剩余金额“，同时有一个”链接“的icon，点击后可以查看这个”旧合同“的最后一个账单（产生这个”剩余金额“的账单）。

57. 在”延期账单“(defer)的时候要选择是否将员工工资一起延期。（这实际上是一个账单合并的功能，将本月账单与下月账单一起计算和支付）

58. 添加”试工合同“的时候同时要输出”月薪“并按”月薪“计算劳务费以及加班费，目前是按”日薪“计算的，会和实际有偏差。[已完成]

59. 根据微信支付的”转账“账单，自动对应收入的金额，来对阿姨应缴款进行”已支付“操作。同时有些给客户的退款，有可能也是微信，这部分要和”银行对仗中心综合处理。！！

60. 合同管理

61. 业务遇到的问题：非自动月签合同，在月中续约的时候，工资以及费用的转移问题：[已完成]
    示例：
    合同A 2024-09-10 ~ 2025-09-10 结束，25年9月账单中有10天的员工工资会通过保证金支付
    合同B，是A合同的新签 2025-09-11 ~ 2026-09-11结束。 
    这样合同B在9月有20天工资要付给员工
    a退还的保证金会自动转为B首月的保证金，因此实际上A就没有保证金代付工资了，同时将A中的员工工资转到B合同的首月账单中。

    建议的解决方案
    在A合同的最后一个月账单中，需要判断当前相同的客户与员工是否有后续合同B（开始日期小于等于此最后一个月账单结束日期），如果有的话，出现一个”合并账单”的功能，点击后完成以下操作：
    1. 将A合同中最后一个月的”保证金退款“自动转移到B合同首期账单中，同时产生相应的冲抵项（此处相当于人工”转移“操作的数据处理逻辑一致）
    2. 将员工工资单中的”代付总额“金额转移到B合同首月员工工资单中（财务调整项 ”EMPLOYEE_CLIENT_PAYMENT“，备注为”转移支付原合同剩余的员工工资”，并提供链接可以跳转到A合同的最后一期账单），同时在A合同最后一期账单的员工工资单中增加财务调整项用来冲抵此工资单中的应发总额（财务调整项类型为”EMPLOYEE_DECREASE“，备注为”转移到新合同中合并支付员工工资“，并提供链接可跳转到B合同首期账单）
    3. 如果A合同最后一期账单中存在”COMPANY_PAID_SALARY“ 公司代付工资 或 ”DEPOSIT_PAID_SALARY“保证金代付工资 等财务调整项，要删除。
    最终的目的是，A合同末期账单中客户账单”应收总额“为0，员工账单中的”应发总额“也是0.B账单中合并付 员工 的整月工资

62. 如果是合同A的首期账单，需要检查此客户是否有已终止或已完成的合同B，提示用户将合同B末期账单中需要退还的保证金转入到此合同A的首期账单中。减少合同见转移保证金的人工操作，和查询操作。[已完成]

63. 员工工资单中不再体现被替班扣款和被替班扣除的天数[已完成]

64. 在“用户管理“中区分一下“未激活”的人不显示，增加筛选项，默认只显示“已激活”的人员

65. 将考试结果显示在 mengyimengsao.com 正式简历中，并增加开关，来控制“是否显示考核结果”

BUG
1. 添加替班后，没有即时显示替班记录[已完成]
2. 支付记录支付后，账单列表没有更新”待付“金额。【改为其他需求】
3. 修改劳务时间时，可以精确到小数点后两位，例如11.43天。[已完成]
4. 对一个已完成的育儿嫂合同，先延长服务天，再继续添加一个合同外的月嫂替班（延长之后的服务期之外的替班），替班管理费填写的是15%，此时这个替班账单的管理费率会有问题（85000%），还会有“延长期管理费”将前面延长的服务天数放到了这个替班账单中！[已完成]
5. 添加替班的时候替班记录中的员工显示的是被替班员工的名字，而不是替班员工的名字！[已完成]
6. 银行对账中心中，分配客户回款的时候，如果客户只有合同没有账单时，没有显示“相关合同”了，这个功能以前有，现在被改没了，需要恢复 [已完成]
7. 在账单列表，弹出的账单详情中完成“员工应缴款已支付”的时候，账单列表中的“待缴款”状态及金额没有即时更新。[已完成]
8. 在财务调整项中，点击某个调整项，并设置为”已结算“，金额不会计入”实收总额“中，这样在删除这条退款的支付记录时就有问题了！！[已完成]
9. 月嫂替班管理费率没有从页面上获取，而是写死了的25%？[已完成]
10. 试工合同转移时，介绍费2000不应该自动变为已支付。[已完成]
11. 对账中心，账单详情，无法跳转到已转移费用的替班账单[已完成]



---
## 本次开发周期总结 (截至 2025年8月21日)

**状态：** 完成了财务调整项的通用化转移与结算联动功能的开发。

1.  **【功能】通用化财务调整项转移**:
    *   **需求**:将原仅限于“保证金退款”的转移功能，扩展至所有类型的财务调整项，并允许在没有下一期账单时，跨合同进行转移。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 重构了 `transfer_financial_adjustment`接口，移除了对调整项描述的硬编码限制。增加了“智能寻路”逻辑，使其优先尝试转移至同一合同的下一期账单，仅在无后续账单时才需要前端提供目标合同ID。
        *   **前端 (`FinancialManagementModal.jsx`)**:适配了新的后端逻辑，实现了两步式转移交互。当后端返回需要用户选择的信号时，前端会弹出合同选择对话框，引导用户完成操作。同时，优化了转移相关条目的描述，使其能清晰地展示来源和去向。
2.  **【功能】结算与收付款记录双向联动**:
    *   **需求**:将“结算”操作与真实的“收/付款记录”完全打通，并修复了多项关联的计算与显示问题。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 彻底重构了 `_apply_all_adjustments_and_settlements` 函数。现在，当一个调整项被标记为“已结算”时，系统会自动创建一条对应的`PaymentRecord` 或`PayoutRecord`。反之，当“取消结算”或删除调整项时，关联的记录也会被一并删除。
        *   **前端 (`FinancialManagementModal.jsx`)**:简化了前端的计算逻辑，现在“实收/实付总额”完全由后端返回的、已包含所有记录的总额为准，修复了重复计算的问题。同时，增加了多项操作限制，如禁止转移或删除已结算的条目，提升了系统的健壮性。


---
## 本次开发周期总结 (截至 2025年8月20日)

**状态：** 完成了财务记录的图片凭证上传功能，并重构了员工首月服务费的核心逻辑。

1.  **【功能】财务记录图片凭证 (`FinancialManagementModal.jsx`,`PaymentDialog.jsx`, `PayoutDialog.jsx`)**:
    *   **需求**: 在创建收款或付款记录时，允许用户上传图片作为凭证。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 重构了创建支付记录的API (`/payments`,`/payouts`)，使其能在一个请求中同时接收表单数据和图片文件(`multipart/form-data`)，保证了操作的原子性。
        *   **前端**: 调整了 `PaymentDialog` 和 `PayoutDialog`，使其通过`FormData` 对象打包并发送所有数据。在 `FinancialManagementModal`的记录表格中增加了“凭证”列，提供图标链接，可点击查看上传的图片。
        *   **BUG修复**: 解决了在此过程中出现的一系列问题，包括CORS预检请求失败(`404`, `400`)、媒体类型不匹配 (`415`)、以及因URL路径错误导致的 `404`。

2.  **【功能】员工首月10%服务费逻辑重构 (`billing_engine.py`)**:
    *   **需求**:将此费用变为明确的“财务调整项”，并且仅在员工与客户首次合作时收取。
    *   **解决方案**:
        *   **计费引擎 (`billing_engine.py`)**:
            *   在 `_calculate_nanny_details`中增加了数据库查询逻辑，用于检查当前员工与客户之间是否存在更早的合同。
            *   只有在不存在历史合作记录的情况下，才创建类型为`EMPLOYEE_DECREASE`、描述为“[系统添加] 员工首月服务费”的 `FinancialAdjustment`记录。
            *从最终金额的直接计算中移除了该扣款项，使其完全由调整项机制处理。

3.  **【修复】计算日志总金额错误 (`billing_engine.py`)**:
    *   **问题**: 当计算结果为负数时，日志中的总金额错误地显示为0。
    *   **解决方案**: 修复了 `_create_calculation_log`函数中处理数字字符串的逻辑，使用 `try-except` 代替 `.isdigit()`，确保负数能够被正确转换和显示。同时，补全了总额计算日志中缺失的费用项。



---

## **财务记录与收付款功能需求 (FRD)**

### 1. 项目概述

#### 1.1. 背景与目标

当前系统已具备完善的合同管理与自动账单生成能力。然而，对于实际资金流水的记录、追踪和核对仍依赖于线下操作，导致数据分散、核对困难，且无法与核心业务（合同、账单）数据形成闭环。

本项目旨在开发一个统一的“财务记录与收付款”功能模块。其核心目标是：**建立一个集中、准确、可追溯的财务流水账本，并确保其与系统内的合同、客户账单、员工薪酬单等业务源头数据实时同步、完全一致。**

#### 1.2. 核心原则：数据同源与双向同步

本功能的设计必须遵循一项核心原则：**数据同源与双向同步**。这意味着：

- **数据同源**: 系统中每一笔收付款记录都必须能追溯到其业务源头，如一笔管理费、一项人工调整款或一笔合同介绍费。
- **双向同步**: 对源头数据的操作（如标记付款）会自动生成财务记录；反之，在财务模块中新增的记录（如一笔临时收款）也必须自动在源头（如客户账单）中创建对应的调整项，确保系统账目永远平衡。

### 2. 功能范围

#### 2.1. 范围内 (In Scope)

- 记录所有与公司、客户、员工相关的资金流入与流出。
- 对每一笔资金流水进行分类和标记。
- 查看、筛选和搜索财务流水历史。
- 将流水记录与其业务源头（合同、账单、调整项）进行关联。
- 支持特殊的财务操作，如款项顺延和保证金转移。

#### 2.2. 范围外 (Out of Scope)

- 完整的会计核算功能（如生成资产负债表、利润表）。
- 税务计算与申报功能。
- 与银行或第三方支付平台的API直接对接。

### 3. 功能性需求 (Functional Requirements)

#### 3.1. 财务流水记录 (Transaction Recording)

- **FR-1.1 (手动创建)**: 系统必须允许授权用户（如财务人员）手动创建一笔新的财务流水记录。创建时必须包含以下信息：
  - 金额
  - 收/付款日期
  - 付款方 (可从客户、员工、公司中选择)
  - 收款方 (可从客户、员工、公司中选择)
  - **资金分类** (见 3.2)
  - 支付渠道/方式 (如银行转账、微信、现金等)
  - 备注/说明
  - (可选) 关联的合同或账单
- **FR-1.2 (从源头生成)**: 在系统的账单详情页或合同详情页，用户必须能够对具体的费用项（如管理费、介绍费、财务调整项）执行“标记收款”或“标记付款”操作，系统将根据该费用项的信息**自动生成**一条对应的财务流水记录。

#### 3.2. 资金分类体系 (Transaction Classification)

- **FR-2.1**: 系统必须提供一个灵活的、可配置的资金分类体系。所有财务流水都必须归属到一个明确的分类下。初始分类体系必须支持以下结构：
  - **收款 (资金流入公司)**
    - **来自客户**: 管理费、保证金、介绍费、定金、10%返还、其他增款。
    - **来自员工**: 宿舍费、管理费、其他扣款。
  - **付款 (资金流出公司)**
    - **付至客户**: 退还保证金、退还管理费、退还介绍费、退还定金、其他退款。
    - **付至员工**: 劳务费 (代付)、奖金。
  - **其他流水 (公司不经手，仅作记录)**
    - **客户付员工**: 劳务费、红包、报销。
    - **员工付客户**: 退还劳务费。

#### 3.3. 数据双向同步 (Bi-directional Synchronization)

- **FR-3.1 (正向同步)**: 当用户通过 **FR-1.2** 的方式从源头生成一笔财务流水后，源头费用项的状态应更新为“已处理”或“已支付”，防止重复操作。
- **FR-3.2 (反向同步)**: 当用户通过 **FR-1.1** 的方式手动创建一笔收款或付款，并将其关联到某个客户账单或员工薪酬单时，系统**必须自动**在该账单/薪酬单下创建一条对应的“财务调整项”(FinancialAdjustment)。该调整项的金额、说明应与新创建的财务流水保持一致，从而确保账单的总金额能被实时、准确地更新。

#### 3.4. 流水管理与查询 (Transaction Management & Query)

- **FR-4.1 (列表视图)**: 系统必须提供一个财务流水中心页面，以列表形式展示所有记录。列表中应清晰显示每条流水的关键信息（日期、金额、收付方、分类、状态）。
- **FR-4.2 (筛选与搜索)**: 列表页面必须提供强大的筛选和搜索功能，至少支持按以下条件进行组合查询：
  - 日期范围
  - 金额范围
  - 付款方/收款方 (支持模糊搜索)
  - 资金分类
  - 关联的合同/客户/员工
- **FR-4.3 (编辑与作废)**: 用户必须能够对已创建的财务流水进行编辑或作废。
  - 如果该流水是通过**反向同步**创建的，那么在作废该流水时，系统必须同步作废其关联的“财务调整项”，以维持账目平衡。

#### 3.5. 特殊财务操作 (Special Operations)

- **FR-5.1 (款项顺延)**: 对于某些费用项（尤其是财务调整项），用户必须能够将其标记为“顺延至下期”。被标记后，该款项不计入本期账单的应收/应付总额，而是自动出现在该合同的下一个账单周期中。
- **FR-5.2 (保证金转移)**: 对于合同结束时产生的“保证金退款”项，用户必须能够执行“转移”操作，将其定向转移至同一客户名下的另一份有效合同中。系统必须自动完成以下操作：
  - 在原账单中，将该笔退款标记为“已转移”。
  - 在目标合同的账单中，创建一笔等额的“转入款”作为预收款。
  - 确保两边账目清晰、平衡，并提供可追溯的链接。

### 4. 非功能性需求 (Non-Functional Requirements)

- **NFR-1 (数据一致性)**: 所有涉及多步操作的财务流程（如双向同步、转移）必须是原子化的。操作要么完全成功，要么完全失败回滚，不允许出现中间状态。
- **NFR-2 (审计与追溯)**: 任何对财务流水的创建、修改、作废操作，都必须记录详细的操作日志，包含操作人、操作时间及变更内容。
- **NFR-3 (可用性)**: 界面设计应直观易用，常用操作（如标记付款、创建流水）的步骤应尽可能简化。
- **NFR-4 (安全性)**: 必须建立基于角色的访问控制机制，只有授权用户（如财务角色）才能执行创建、修改和删除等敏感操作。



---

## 功能开发：创建虚拟合同 & 保证金转移

**状态：** 完成了“保证金转移”和“创建虚拟合同”两大核心功能的开发，并修复了多项关联的业务逻辑和技术问题。

1.  **【功能】保证金转移 (`FinancialManagementModal.jsx`, `TransferDepositDialog.jsx`)**:
    *   **需求**: 允许将已结束合同的保证金退款，定向转移至同一客户的新合同中。
    *   **解决方案**:
        *   **后端 (`billing_api.py`, `models.py`)**: 新增了 `details` 字段用于追踪转移状态，并创建了 `POST/api/billing/financial-adjustments/.../transfer`接口。该接口采用“三录式”记账法（更新源、创建转入项、创建冲抵项），确保了源账单在转移后账目自动平衡。
        *   **计费引擎 (`billing_engine.py`)**: 优化了 `_handle_security_deposit`函数，使其能够智能识别并跳过已被处理的转移款项，避免了在账单重算过程中数据被错误覆盖的问题。
        *   **前端**: 新增了“转移”按钮和独立的 `TransferDepositDialog.jsx`弹窗组件，该组件可自动搜索并列出当前客户名下所有可选的目标合同。同时，实现了转入款项到源合同的超链接跳转，方便溯源。

2.  **【功能】创建虚拟合同 (`CreateVirtualContractModal.jsx`, `ContractList.jsx`)**:
    *   **需求**: 为非“金数据”来源的客户，提供在系统内部手动创建合同的渠道。
    *   **解决方案**:
        *   **后端 (`billing_api.py`, `models.py`, `tasks.py`)**:
            *   为合同模型增加了 `source` 字段以区分来源，并为 `pypinyin` 添加了依赖。
            *   新增了 `GET /personnel/search` 和 `GET /customers/search` 接口，以支持前端的动态搜索。
            *   实现了核心的 `POST /api/contracts/virtual`接口，该接口复用了“查找或创建”人员的逻辑，并能自动为新创建的育儿嫂合同触发异步的账单生成和续签检查任务。
        *   **前端**: 创建了功能完善的 `CreateVirtualContractModal.jsx` 组件，其中包含：
            *   与后端接口联动的、带“创建新条目”功能的客户与员工自动补全搜索框。
            *   根据所选合同类型，动态显示/隐藏不同表单字段的逻辑。
            *   为月嫂合同增加了“预产期”自动计算“起止日期”、以及“级别/保证金/费率”双向联动计算的智能交互，大幅提升了用户体验。
            *   实现了创建成功后自动跳转到新合同详情页的流程。

3.  **【修复】后台任务稳定性 (`tasks.py`)**:
    *   **问题**: 创建虚拟合同后，后台的账单生成任务因数据库事务隔离级别，无法立即找到新创建的合同记录，导致任务失败。
    *   **解决方案**:
        *   重构了相关的Celery任务（`generate_all_bills_for_contract_task` 和 `post_virtual_contract_creation_task`），为其增加了`bind=True` 和自动重试逻辑 (`self.retry()`)。
        *   在任务的 `finally` 块中，强制执行 `db.session.remove()`，确保每个任务都使用全新的数据库会话，彻底解决了跨进程数据可见性问题。
4.  遗留问题，创建育儿嫂合同没有填写“客交保证金”

---
## 功能设计：保证金转移 (v10.0 - 已完成)

### 1. 核心目标 (The Why)

为合同结束时系统自动生成的“保证金退款”财务调整项，增加一个“转移”功能。允许运营人员将这笔款项从当前已结束的合同，直接转移至客户名下的另一份新合同中，作为新合同的预收款，并确保整个过程在财务记录上清晰、可追溯。

### 2. 后端设计 (Backend)

#### 2.1. 数据模型 (`FinancialAdjustment` Model)

*   **字段扩展**: 为 `FinancialAdjustment` 模型增加了一个 `details: JSONB` 字段。
*   **功能**: 此字段用于存储转移操作的元数据，包括：
    *   **转出项**: 记录 `status: 'transferred'`，并关联目标合同及新生成的“转入项”ID。
    *   **转入项**: 记录 `status: 'transferred_in'`，并关联来源合同及原始的“转出项”ID。
    *   **冲抵项**: 记录 `offset_for_adjustment_id`，关联到被冲抵的“转出项”ID。

#### 2.2. API 接口设计

*   **接口路径**: `POST /api/billing/financial-adjustments/<adjustment_id>/transfer`
*   **请求体**: `{ "destination_contract_id": "目标合同的UUID" }`
*   **核心处理流程**:
    1.  **权限与数据校验**: 验证操作权限、调整项类型、合同归属等。
    2.  **原子化操作**: 在一个数据库事务中，同时完成三项数据库写入：
        a.  **更新源调整项**: 修改原“保证金退款”的 `description` 和 `details` 字段，将其标记为“已转移”。
        b.  **创建转入项**: 在目标合同的**第一个**账单下，创建一条新的、类型为“客户减款”的财务调整项，用以冲抵新合同的应付款。
        c.  **创建冲抵项**:在源合同的账单下，创建一条新的、类型为“客户增款”的财务调整项，其金额与“已转移项”完全相抵，确保源账单的账目平衡。
    3.  **触发重算**: 在事务成功提交后，自动触发对源合同和目标合同的账单重算任务。
    4.  **返回结果**: 在成功后，向前端返回最新的财务调整项列表，以便刷新UI。

#### 2.3. 计费引擎 (`BillingEngine`)

*   **`_handle_security_deposit` 函数优化**: 修改了此函数中的 `delete` 逻辑，使其在清理时，通过 `details IS NULL`条件，能精确地跳过所有被“转移”功能处理过的特殊调整项，避免了在重算过程中误删数据的问题。

### 3. 前端设计 (Frontend)

#### 3.1. UI/UX 流程

*   **触发点**: 在“财务管理”弹窗的财务调整列表中，为符合条件的“保证金退款”条目，增加一个“**转移**”按钮。
*   **转移弹窗 (`TransferDepositDialog.jsx`)**:
    *   点击“转移”按钮，弹出一个独立的对话框。
    *   该弹窗会自动调用 `GET /api/billing/customers/search` 接口，获取并显示该客户名下所有其他有效的合同，供用户选择。
*   **状态同步**:转移成功后，后端接口会返回源账单上最新的调整项列表，前端会用此数据强制刷新当前弹窗的状态，避免了因“状态陈旧”导致后续操作（如点击保存）出错的问题。
*   **链接渲染**: 在财务调整列表中，`description` 为“[系统添加]其他合同转移保证金退款”的条目，其“其他合同”四个字会被渲染成一个超链接，点击可直接跳转到对应的源合同详情页，方便溯源。

## 功能设计：合同冲突检测 (v9.0 - 已完成)

### 1. 核心目标 (The Why)

系统中的“自动续签”合同，在实际业务中可能已经口头终止，但未在系统中操作。此功能旨在通过数据分析，找出在同一时间段内存在服务时间重叠的“冲突合同”，将其呈现给运营人员，由人工判断并对异常合同执行终止操作，从而保证账单的准确性。

### 2. 冲突类型定义

1.  **员工冲突 (高风险)**:同一个服务人员，在相同或重叠的时间段内，被分配给了多个不同的客户。这通常意味着其中至少有一份合同是需要被终止的“僵尸合同”。
2.  **客户冲突 (中等风险)**:同一个客户，在相同或重叠的时间段内，拥有多个服务中的合同。这可能是正常的（例如一个客户同时雇佣了月嫂和育儿嫂），但也可能是异常的（例如旧合同未终止就签了新合同），需要人工核实。

### 3. 功能需求详述 (The What)

#### 3.1. 后端数据接口 (API)

*   **新建 API 端点**: `GET /api/billing/conflicts`
*   **功能**: 接收一个月份作为参数，返回该月份内所有存在“员工冲突”和“客户冲突”的合同列表。
*   **请求参数**:
    *   `billing_month` (字符串, 格式: "YYYY-MM"): 需要检测的目标月份。
*   **后端逻辑**:
    1.  获取目标月份的所有有效账单 (`CustomerBill`)。
    2.  **员工冲突检测**:
        *   按 `employee_id` 将所有账单分组。
        *   在每个员工的分组内，两两比较账单的服务周期 (`cycle_start_date` ~ `cycle_end_date`)。
        *   如果发现任何两个账单的周期存在重叠（`StartA <= EndB` and `EndA >= StartB`），则将这两份（或多份）冲突的账单信息记录下来。
    3.  **客户冲突检测**:
        *   按 `customer_name` 将所有账单分组。
        *   执行与员工冲突检测相同的周期重叠比较逻辑。
    4.  **返回数据**: 返回一个包含 `employee_conflicts` 和 `customer_conflicts` 两个数组的JSON对象。

#### 3.2. 前端界面 (`conflict_checker.html`)

*   **页面标题**: “合同冲突检测”
*   **页面布局**:
    *   **顶部**: 一个月份选择器和“**开始检测**”按钮。
    *   **结果区**: 默认隐藏，点击按钮后显示。分为左右两栏，分别显示“员工冲突”和“客户冲突”的结果。
*   **结果展示**:
    *   每个冲突以一张独立的**卡片**形式展示，卡片头部显示冲突主体（如“员工: 王阿姨”）。
    *   卡片内容以列表形式，清晰地展示每一份相互冲突的合同信息，包括客户/员工姓名、合同类型、冲突的服务周期，以及一个“**处理**”按钮。
*   **交互逻辑**:
    *   点击“处理”按钮，页面将跳转到对应的**合同详情页**，运营人员可在此页面执行“终止合同”操作。

---

## 本次开发周期总结 (截至 2025年8月13日)

**状态：** 完成了合同冲突检测功能的开发，并对仪表盘和权限控制进行了优化。

1.  **【功能】合同冲突检测 (`ConflictCheckerPage.jsx`)**:
    *   **需求**: 通过数据分析，找出在同一时间段内存在服务时间重叠的“冲突合同”，呈现给运营人员处理。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 新增了 `GET /api/billing/conflicts` 接口，根据月份参数，检测并返回“员工冲突”和“客户冲突”两类合同列表。
        *   **前端**: 创建了全新的“合同冲突检测”页面，允许用户选择月份进行检测，并在界面上以卡片形式清晰地展示冲突的合同信息，包括关联合同的周期、金额等，并提供直接跳转到合同详情页进行处理的功能。

2.  **【优化】运营仪表盘 (`DashboardPage.jsx`)**:
    *   **需求**: 扩展数据可视化维度，提供更长周期的数据洞察和更多维度的业务分析。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 增强了 `/api/dashboard/summary` 接口。
        *   **前端**:
            *   将“月度管理费收入趋势”柱状图的展示周期从6个月延长至12个月。
            *   新增了一个“管理费构成”饼图，用于按合同类型（月嫂、育儿嫂等）展示管理费收入占比，并支持按“今年”和“最近12个月”两个时间维度进行切换查看。

3.  **【安全】权限系统加固 (`PrivateRoute.jsx`)**:
    *   **问题**: `Sidebar.jsx` 中的 `adminOnly` 参数仅控制菜单的显示，无法阻止非管理员用户通过直接访问URL来打开受限页面。
    *   **解决方案**:
        *   修改了 `PrivateRoute.jsx` 组件，使其能够读取 `Sidebar.jsx` 中导出的路由配置。
        *   在路由层面实现严格的权限检查，如果路由被标记为 `adminOnly`，而当前登录用户非管理员，系统将自动将其重定向，从而彻底修复了越权访问漏洞。

## 

## 本次开发周期总结 (截至 2025年8月12日)

**状态：** 完成了运营仪表盘的开发，并对账单列表、合同详情等核心功能进行了多项优化与修复。

1.  **【功能】运营仪表盘 (`DashboardPage.jsx`)**:
    *   **需求**: 为运营和决策者提供一个核心业务数据概览页面。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 新增了 `GET /api/dashboard/summary` 接口，用于提供仪表盘所需的KPI、图表和待办事项数据。
        *   **前端**: 创建了全新的仪表盘页面，包含核心KPI卡片（如年度收入、活跃客户数等）、月度收入趋势图，以及包含待收款、待付款、即将到期合同的关键待办事项列表。

2.  **【功能】批量结算功能 (`BatchSettlementModal.jsx`)**:
    *   **需求**: 提升财务结算效率，支持批量更新账单的付款和领款状态。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 新增了 `POST /api/billing/batch-settle` 接口，在一个事务中原子化地处理批量更新。
        *   **前端 (`BillingDashboard.jsx`)**: 在账单列表页增加了复选框和触发按钮，并创建了批量操作弹窗，支持“同上”等快捷操作。

3.  **【功能】账单列表优化 (`BillingDashboard.jsx`)**:
    *   **总计与导出**: 在列表头部增加了当前筛选条件下的管理费总计，并提供了将明细导出为CSV文件的功能。
    *   **UI/UX 优化**: 将操作按钮改为图标，优化了日期显示格式，增加了“顺延”操作的二次确认弹窗，并将默认每页行数提升至100。

4.  **【功能】合同详情编辑功能增强 (`ContractDetail.jsx`)**:
    *   **需求**: 允许运营人员在合同详情页单独编辑“介绍费”和追加“运营备注”。
    *   **解决方案**:
        *   **模型 (`models.py`)**: 调整了 `BaseContract` 模型，将 `introduction_fee` 字段移至基类。
        *   **后端 (`billing_api.py`)**: 增强了合同更新接口，使其能处理介绍费的修改和备注的追加逻辑。
        *   **前端**: 为相关字段实现了行内编辑功能。

5.  **【BUG修复】核心账单逻辑**:
    *   修复了替班账单的加班更新、薪酬模板显示错误的问题。
    *   修复了被替班的主账单在重新计算后，`calculation_details` 字段未被持久化的问题。
    *   修复了批量更新时因 `datetime.date` 对象导致的JSON序列化错误。
    *   修复了管理费总计因 `JOIN` 查询导致重复计算的问题。

---

## 功能设计：运营仪表盘 (v8.0 - 已完成)

### 1. 核心目标 (The Why)

为运营人员和决策者（CEO）提供一个“一站式”的业务健康度概览页面。通过数据可视化，将系统中最关键的指标（KPIs）、业务趋势和待办事项直观地呈现出来，替代从繁杂的表格中人工查找和总结，从而支持更快速、更精准的业务决策。

### 2. 仪表盘模块设计 (The What)

#### 模块一：核心绩效指标 (KPIs)

1.  **`预计年度收入`**:
    *   **含义**: 公司本年度的预估总收入。
    *   **计算**: `本年度所有账单的管理费总额` + `本年度所有合同的介绍费总额`。

2.  **`年度管理费 (已收/应收)`**:
    *   **含义**: 直观展示本年度核心收入（管理费）的回款情况。
    *   **计算**: 卡片内显示两个数字，例如 `¥850,000 / ¥1,200,000`。前者是本年度已支付账单的管理费总和，后者是本年度所有账单的管理费总和。

3.  **`活跃客户数`**:
    *   **含义**: 当前正在服务中的客户总数。
    *   **计算**: 从所有状态为 `active` 的合同中，统计不重复的客户 (`customer_name`) 数量。

4.  **`在户员工数`**:
    *   **含义**: 当前正在客户家中提供服务的员工总数。
    *   **计算**: 从所有状态为 `active` 的合同中，统计不重复的服务人员 (`user_id` 或 `service_personnel_id`) 数量。

#### 模块二：收入趋势 - 月度管理费收入图表

*   **形式**: 柱状图 (Bar Chart)。
*   **数据**: 最近6个月中，每个月的管理费总收入。

#### 模块三：核心待办事项列表

*   **`本月待收管理费`**: 列出本月所有未支付的管理费账单，包含客户、合同类型和金额。
*   **`本月待付员工薪酬`**: 列出本月所有未支付的员工薪酬单，包含员工、合同类型和金额。
*   **`即将到期合同`**: 列出所有剩余有效期少于30天的活跃合同，包含客户、员工、到期日和剩余天数，提醒运营跟进续签。

---

## 功能设计：批量支付与领款结算 (v7.0 - 已完成)

### 1. 核心目标 (The Why)

旨在解决财务或运营人员在月底需要对大量账单进行结算时，逐一点击、更新状态效率低下的痛点。通过提供一个集中的批量处理界面，并辅以“同上”等快捷操作，最大程度地减少重复性数据录入，加速月度结算流程。

### 2. 业务场景 (User Story)

作为一名运营人员，我希望能在账单列表页一次性勾选多张待结算的账单，点击“批量结算”按钮后，在一个弹窗内集中处理这些账单。我可以在这个弹窗里，为每一行账单快速勾选“客户已打款”和“员工已领款”，并方便地录入对应的日期和渠道/备注。对于日期或渠道相同的情况，我希望能通过点击“同上”按钮一键填充，从而高效地完成结算工作。

### 3. 功能需求详述 (The What)

#### 3.1. 前端界面 (UI/UX)

*   **触发点 (`BillingDashboard.jsx`)**:
    1.  在现有的账单列表页，表格的上方或下方增加一个 **“批量结算”** 按钮。
    2.  表格的每一行需要增加一个复选框（Checkbox）。
    3.  “批量结算”按钮默认禁用，仅当用户勾选了至少一个账单时才被激活。

*   **批量结算弹窗 (`BatchSettlementModal.jsx` - 新建组件)**:
    1.  点击“批量结算”按钮后，弹出一个新的模态窗口。
    2.  窗口内以表格形式展示所有被勾选的账单信息。
    3.  **表格列定义**:
        *   `客户姓名` (只读)
        *   `服务人员` (只读)
        *   `应付金额` (只读)
        *   **`客户已打款`**: 一个 **复选框**。
        *   **`打款日期`**: 一个**日期选择器**。仅在该行的“已打款”复选框被勾选时激活。
        *   **`打款渠道/备注`**: 一个**文本输入框**。仅在该行的“已打款”复选框被勾选时激活。
        *   **`员工已领款`**: 一个 **复选框**。
        *   **`领款日期`**: 一个**日期选择器**。仅在该行的“已领款”复选框被勾选时激活。
        *   **`领款渠道/备注`**: 一个**文本输入框**。仅在该行的“已领款”复选框被勾选时激活。
    4.  **“同上”快捷功能**:
        *   在“打款日期”的**列头**，提供一个“同上”按钮。点击后，将**第一行已填写的**“打款日期”复制到下方所有行的“打款日期”输入框中。
        *   “打款渠道/备注”、“领款日期”、“领款渠道/备注”三列也提供相同的“同上”按钮，逻辑一致。
    5.  **操作按钮**:
        *   一个“**保存**”按钮，用于提交所有更改。
        *   一个“**取消**”按钮，用于关闭弹窗。

#### 3.2. 后端接口 (API)

*   **新建 API 端点 (`billing_api.py`)**:
    *   **路径**: `POST /api/billing/batch-settle`
    *   **请求体 (Request Body)**: 前端将发送一个包含所有待更新账单信息的数组。
        ```json
        {
          "updates": [
            {
              "bill_id": "uuid-of-bill-1",
              "customer_is_paid": true,
              "customer_payment_date": "2025-08-13",
              "customer_payment_channel": "支付宝",
              "employee_is_paid": true,
              "employee_payout_date": "2025-08-14",
              "employee_payout_channel": "招商银行"
            },
            {
              "bill_id": "uuid-of-bill-2",
              "customer_is_paid": false,
              "employee_is_paid": true,
              "employee_payout_date": "2025-08-14",
              "employee_payout_channel": "招商银行"
            }
          ]
        }
        ```
*   **后端处理逻辑**:
    1.  接收 `updates` 数组并开始一个数据库事务。
    2.  遍历数组中的每一项。
    3.  根据 `bill_id` 查找对应的 `CustomerBill` 和 `EmployeePayroll` 记录。
    4.  更新 `is_paid` 状态。
    5.  将收款和付款的日期、渠道等信息更新到 `payment_details` 和 `payout_details` 这两个 JSON 字段中。
    6.  为每一条被修改的记录创建一条 `FinancialActivityLog` 操作日志。
    7.  所有操作成功后，提交整个事务。若中途有任何失败，则完全回滚，保证数据一致性。
    8.  返回操作成功的信息。

#### 4. 数据库模型 (`models.py`)

*   **无需修改**。现有的 `CustomerBill` 和 `EmployeePayroll` 模型中的字段（`is_paid`, `payment_details`, `payout_details`）已能完全支持此功能。

#### 5. 实施步骤

1.  **后端开发**:
    *   在 `backend/api/billing_api.py` 中实现新的 `POST /api/billing/batch-settle` 端点。
    *   编写 `batch_settle` 函数的业务逻辑。
2.  **前端开发**:
    *   创建新的 `BatchSettlementModal.jsx` 组件。
    *   在 `BillingDashboard.jsx` 中添加触发按钮和将选中账单传递给弹窗的逻辑。
    *   实现弹窗内的表格、表单控件和“同上”功能。
    *   实现保存按钮到后端API的调用，并处理加载状态和反馈信息。

---

## 本次开发周期总结 (截至 2025年8月11日)

**状态：** 完成了高级发票管理功能的开发与相关逻辑修正。

1.  **【功能】高级发票管理与动态余额追踪:**
    *   **需求**: 实现一个能处理跨月欠票、支持单张账单多次开票、并能精确计算发票余额的健壮系统。
    *   **解决方案**:
        *   **模型 (`models.py`)**: 增强了 `InvoiceRecord` 模型，使其与 `CustomerBill` 直接关联，并为 `CustomerBill` 增加了 `invoice_needed` 开关，实现了“一账单对多发票”的数据结构。
        *   **计算引擎 (`billing_engine.py`)**: 重写了 `calculate_invoice_balance` 函数。现在的计算逻辑基于“管理费”，能正确处理跨月度的欠票累计与抵扣，并能将替班账单与主合同的财务历史完全隔离。
        *   **API (`billing_api.py`)**: 升级了 `/details` 和 `/bills` 接口，使其能返回精确的发票状态；重构了 `batch-update` 接口，使其能同步一个完整的发票记录列表（增、删、改）。
        *   **前端 (`FinancialManagementModal.jsx`, `InvoiceDetailsDialog.jsx`)**: 重构了发票管理弹窗，现在支持多张发票的列表显示、新增、编辑和删除。UI逻辑会根据后端的计算结果（如历史欠票）自动更新，提升了用户体验。
        *   **Bug修复**: 解决了多项关联问题，包括日志记录的浮点数精度、UI组件的对齐和显隐逻辑、以及因数据不同步导致的显示错误。


---
## 本次开发周期总结 (截至 2025年8月6日)

**状态：** 完成了对账单计算引擎和数据模型的关键迭代与修复。

1.  **【功能迭代】“延长服务”功能扩展至月嫂合同**:
    *   **需求**: 将原仅支持育儿嫂（非月签）的“延长服务”功能，扩展至月嫂合同，允许其在最后一期账单后延长服务天数并正确计算费用。
    *   **解决方案**:
        *   **后端 (`billing_api.py`)**: 修改了 `_get_billing_details_internal` 函数中的判断逻辑。现在它会同时识别育儿嫂（非月签）和月嫂合同为可延长类型。
        *   **后端 (`billing_api.py`)**: 增强了逻辑，使其在判断月嫂合同是否超期时，会优先使用更准确的 `expected_offboarding_date` (预计下户日期) 作为基准，确保了计算的准确性。

2.  **【BUG修复】替班加班天数精度丢失问题**:
    *   **问题**: 在录入替班记录时，如果加班天数包含小数（如 `4.3` 天），保存后会变成整数 `4`，导致计算错误。
    *   **解决方案**:
        *   **模型 (`models.py`)**: 将 `SubstituteRecord` 模型中的 `overtime_days` 字段类型从 `db.Integer` 修改为 `db.Numeric(5, 1)`，允许精确存储一位小数。
        *   **数据库**: 生成并应用了新的 Alembic 迁移脚本，更新了数据库表结构。
        *   **后端 (`billing_api.py`)**: 修复了因 `Decimal` 对象无法被直接序列化为 JSON 而导致的日志记录失败问题。现在，在调用 `_log_activity` 记录日志前，会将 `Decimal` 类型的加班天数用 `str()` 转换为字符串。

3.  **【BUG修复】月嫂合同末月多账单的重算不准确**:
    *   **问题**: 如果一个月嫂合同在同一个结算月内有两个账单周期（如一个正常周期，一个不足月的末期周期），在更新末期账单的加班天数后，系统会错误地重算当月的第一个账单，而不是当前操作的末期账单。
    *   **解决方案**:
        *   **后端 API (`billing_api.py`)**: 增强了 `batch_update_billing_details` 函数，在调用计费引擎时，额外传递了当前账单的 `cycle_start_date` 作为精确的定位依据。
        *   **计费引擎 (`billing_engine.py`)**: 修改了 `calculate_for_month` 和 `_calculate_maternity_nurse_bill_for_month` 函数，使其能够接收并优先使用 `cycle_start_date_override` 参数来查找并重算**唯一确定**的账单，解决了月份查找的歧义性问题。

4.  **【BUG修复】自动续约合同无法为未来月份创建账单**:
    *   **问题**: 尝试为“月签自动续约”的育儿嫂合同，提前录入下一个月的加班时，系统无法正确创建新月份的账单周期。
    *   **解决方案**:
        *   **计费引擎 (`billing_engine.py`)**: 优化了 `_get_nanny_cycle_for_month` 函数。增加了新的逻辑分支，当判断到是自动续约合同且目标月份在当前合同结束日期之后时，会自动计算并返回新月份的完整周期，确保了为未来月份创建账单的功能可以正常执行。

---
## 本次开发周期总结 (截至 2025年8月2日)

**状态：** 完成了手动调整育儿嫂合同实际劳务天数的功能。

1.  **[已完成]功能增强 - 支持手动调整育儿嫂“实际劳务天数”**:
    *   **需求**: 在育儿嫂合同的账单详情中，允许运营人员手动修改“实际劳务天数”，该值将作为计算“基本劳务费”的依据。
    *   **解决方案**:
        *   **前端 (`FinancialManagementModal.jsx`, `BillingDashboard.jsx`)**: 在账单编辑模式中为“实际劳务天数”增加了计步器控件。修复了父组件 (`BillingDashboard`) 在保存时遗漏该字段的问题，确保了修改后的值能被正确发送到后端。
        *   **后端 (`billing_api.py`)**: 调整了 `batch_update_billing_details` 接口，使其能够接收 `actual_work_days` 参数，并将其作为覆盖项传递给计费引擎。
        *   **计费引擎 (`billing_engine.py`)**: 修改了 `_calculate_nanny_details` 方法。现在，它会优先使用从API传入的 `actual_work_days_override` 值来计算劳务费，仅在无此覆盖值时才回退到默认的计算规则。这确保了用户的输入能被准确地用于账单重算并持久化。

---

## 本次开发周期总结 (截至 2025年7月30日)

**状态：** 完成了一系列针对账单详情、替班逻辑和数据一致性的关键修复。

1.  **【已修复】替班账单管理费计算与日志问题**:
    *   **问题**: 月嫂替班的管理费计算公式错误，且未在日志中正确体现。
    *   **解决方案**:
        *   **后端 (`billing_engine.py`)**: 修正了 `_calculate_substitute_details` 中的管理费计算公式，确保其按“级别 * 费率 / 26 * 天数”的规则计算。同时，在 `_create_calculation_log` 中更新了日志生成逻辑，使其能展示正确的计算过程。

2.  **【已修复】前端账单详情显示逻辑**:
    *   **问题**: 替班账单会显示不应出现的“客交保证金”和“首月员工10%费用”；主账单会显示不相关的替班记录。
    *   **解决方案**:
        *   **前端 (`FinancialManagementModal.jsx`)**:
            *   增加了 `isSubstituteBill` 判断，在渲染时主动隐藏“客交保证金”和“首月员工10%费用”字段。
            *   在账单标题处为替班账单增加了醒目的“替”标签 (`Chip`)。
            *   **关键修复**: 替班记录列表现在会通过 `original_customer_bill_id` 与当前主账单的 `id` 进行精确匹配过滤，确保只显示与当前账单直接相关的替班记录。
        *   **后端 (`contract_api.py`)**: 修正了 `get_substitute_records` 接口，使其在返回数据中包含了 `original_customer_bill_id` 字段，为前端的精确过滤提供了数据基础。

3.  **【已修复】结算与发票信息的数据链路**:
    *   **问题**: 前端保存的打款、领款及发票信息无法正确显示，财务调整项日志记录失效。
    *   **解决方案**:
        *   **恢复保存逻辑 (`billing_api.py`)**: 通过 `git log` 找回了历史提交中正确的 `batch_update_billing_details` 函数逻辑。恢复了对 `settlement_status` 对象的处理，确保前端发送的付款和发票信息能被正确写入数据库的 `payment_details` 和 `payout_details` 字段。
        *   **修复数据显示 (`billing_api.py`)**: 重构了 `_get_billing_details_internal` 和 `_fill_payment_status` 函数，解决了因前后端数据结构键名不匹配（如 `payment_date` vs `customer_payment_date`）导致的信息无法显示问题。现在后端会返回与前端完全匹配的嵌套数据结构。
        *   **恢复财务调整日志 (`billing_api.py`)**: 恢复了 `batch_update_billing_details` 中对财务调整项进行“比较与应用”的逻辑，取代了错误的“先删后增”模式。现在系统可以为每一条调整项的增、删、改操作记录详细、准确的中文操作日志。

4.  **【已修复】合同终止算法**:
    *   **问题**: 月嫂合同提前终止时，最后一个月的账单中，管理费和基本劳务天数未按实际剩余天数计算。
    *   **解决方案**:
        *   **后端 (`billing_engine.py`)**:
            *   修改了 `_calculate_maternity_nurse_bill_for_month`，使其在强制重算时，优先使用数据库中已被正确更新的周期（即以终止日为结束日），确保劳务天数计算正确。
            *   修改了 `_calculate_maternity_nurse_details`，将管理费的计算逻辑从“每期全额收取”更正为“仅在首期一次性收取”，从根本上解决了末期管理费的计算问题。

---

## 第一部分：已确认的数据库模型 (models.py)

这是我们系统的“宪法”，所有代码都必须围绕这个结构来编写。

### 核心模型:

- **BaseContract**: 合同的父模型，采用单表继承策略。关键通用字段如 `customer_name`, `employee_level`, `status`, 以及所有日期字段（`start_date`, `end_date`, `provisional_start_date`, `actual_onboarding_date`）都已定义在此模型中，所有子类共享这些列。
- **NannyContract (育儿嫂合同)**: `BaseContract` 的子类，通过 `type='nanny'` 识别，包含 `is_monthly_auto_renew` 等特有字段。
- **MaternityNurseContract (月嫂合同)**: `BaseContract` 的子类，通过 `type='maternity_nurse'` 识别，包含 `deposit_amount`, `management_fee_rate` 等特有字段。

### 人员模型:

- **User**: 系统内部员工，可登录。
- **ServicePersonnel**: 外部或历史服务人员，不可登录。
- **关联**: `BaseContract` 过 `user_id` 和 `service_personnel_id` 两个可为空的外键来关联到具体人员。

### 业务数据模型:

- **AttendanceRecord**: 考勤记录。已升级为周期模式，通过 `cycle_start_date` 和 `cycle_end_date` 记录，以支持月嫂的跨月考勤。
- **SubstituteRecord**: 替班记录。
- **FinancialAdjustment**: 财务调整项（增/减款）。

### 结果模型:

- **CustomerBill**: 客户月度账单。
- **EmployeePayroll**: 员工月度薪酬单。`employee_id` 字段已移除外键约束，可以存储来自 `User` 或 `ServicePersonnel` 的ID。

---

## 第二部分：业务逻辑与字段映射 (最终审查版)

### **第一部分：通用定义 (适用于所有合同类型)**

为了消除所有歧义，我们首先统一定义关于“天数”的核心字段：

- **天数 **: 
  - 因为业务上精确到时分秒的，因此 天数 = 结束日 -开始。
  -  注意，不需要+1.例如 1月1日至1月31日（实际是1月1日 00:00:00 ~ 1月31日 12:59:59），之间的天数是30天 而不是31天，。
  - 在计算任何“天数”类结果的时候，都遵循此逻辑！

*   **基本劳务天数 (`base_work_days`)**:
    
    *   **含义**: **（已按最新规则重构）** 这是用于**预估和计算基础工资**的、一个账单周期内的**标准工作天数**。它是一个**默认值或基于周期长度的计算值**，**不包含**加班。
    *   **月嫂合同**: 固定为 **26天**。
    *   **育儿嫂合同**:
        *   如果账单周期 **小于26天**，则等于 **实际周期天数**。
        *   如果账单周期 **大于等于26天**，则等于 **26天**。
    
*   **加班天数 (`overtime_days`)**:
    *   **含义**: 员工在本账单周期内的总加班天数。**（已更新）** 不再区分节假日和非节假日。
    *   **来源**: `AttendanceRecord.overtime_days`

*   **被替班天数 **:

    *   **含义**: 合同中的服务人员由于特殊情况请假，但客户家有不能缺少服务人员，因此会选定一个替班员工，因此会产生替班天数
    *   **来源**: 

    

*   **总劳务天数 (`total_days_worked`)**:
    *   **含义**: 员工在本账单周期内，实际工作的总天数。
    *   **计算**: `基本劳务天数 + 加班天数 - 被替班天数 `

---

### **第二部分：月嫂合同 (Maternity Nurse Contract)**

#### 1. 核心定义与周期逻辑

*   **核心定义**:
    *   **级别 (`employee_level`)**: 客户在一个完整26天服务周期内应支付的 **支付给月嫂的纯劳务费，不包含管理费**。
    *   **员工日薪**: `级别 / 26`。
    *   **客户日薪**: `客交保证金 / 26`。
    *   **客交保证金**: 客户缴纳的总费用，包含月嫂的纯劳务费与管理费。用于支付月嫂工资，并在合同结束时多退少补。
    *   **管理费**: **(已更新)** 合同总管理费，计算方式为 `客交保证金 - 级别`。此费用在**第一个账单周期一次性收取**。
    *   **管理费率**: **(已更新)** `管理费 / 客交保证金`。
    
*   **合同日期联动逻辑**:
    *   **初始合同开始日 (`start_date`)**: 默认为 **`预产期 (provisional_start_date)`**。
    *   **日期更新**: 当运营人员填入 **`实际上户日期 (actual_onboarding_date)`** 后，系统会自动：
        1.  用 `实际上户日期` 更新 `合同开始日`。
        2.  计算日期差值：`差值 = 实际上户日期 - 预产期`。
        3.  用 `原合同结束日 + 差值` 来更新 `合同结束日`。

*   **账单周期 (`劳务费时段`)**:
    *   **起点**: `实际上户日期`。
    *   **周期**: 从起点开始，每 **26天** 构成一个账单周期。

---

#### 2. 客户账单 (CustomerBill) - 字段与计算方法

*   **级别**:
    *   **来源**: `BaseContract.employee_level`
*   **定金**:
    *   **来源**: `MaternityNurseContract.deposit_amount`
*   **客交保证金**:
    *   **来源**: `MaternityNurseContract.security_deposit_paid`
*   **劳务费时段**:
    *   **计算**: 根据“账单周期计算逻辑”确定。
*   **基本劳务天数**:
    *   **显示**: `min(账单周期,26天)`
*   **加班天数**:
    *   **来源**: `AttendanceRecord.overtime_days`
*   **总劳务天数**:
    *   **计算**: `26 + 加班天数`
*   **被替班天数**:
    *   **计算**: 其他员工代替此阿姨的“替班天数”
*   **基础劳务费**:
    *   **计算**: `员工日薪 * 基本劳务天数 (即 26)`
*   **加班费**:
    *   **计算**: `客户日薪 * 加班天数`
*   **管理费**:
    *   **含义**: **(已更新)** 整个合同的总管理费。
    *   **计算**: 如果是**第一个账单周期**，则为 `客交保证金 - 级别`；否则为 `0`。
*   **管理费率：**
    *   **计算：**`管理费 / 客交保证金`
*   **优惠**:
    *   **来源**: `MaternityNurseContract.discount_amount`
*   **客增加款 / 退客户款**:
    *   **计算**: 汇总相应类型的 `FinancialAdjustment` 金额。
*   **客应付款**:
    *   **计算**: `基础劳务费 + 加班费 + 管理费 - 优惠 + 客增加款 - 退客户款`
    *   **末月特殊逻辑**: 如果是最后一个账单周期，还需在此基础上减去 **`客交保证金`**。

---

#### 3. 员工薪酬 (EmployeePayroll) - 字段与计算方法

*   **基本劳务天数**:
    *   **显示**: min(账单周期,26天)
*   **加班天数**:
    *   **来源**: `AttendanceRecord.overtime_days`
*   **被替班天数**:
    *   **计算**: 其他员工代替此阿姨的“替班天数”，只用来显示。不用来参与任何计算
*   **总劳务天数**:
    *   **计算**: `26 + 加班天数 - 被替班天数  `
*   **萌嫂保证金(工资)**:
    *   **计算**: `员工日薪 * 基本劳务天数 (即 26)`
*   **加班费**:
    *   **计算**: `客户日薪 * 加班天数`
*   **5%奖励**:
    *   **条件**: `management_fee_rate` 为 15%。
    *   **计算**: `级别 * 5%`
    *   **支付**：只在首月支付，其他月份不再重复支付。
*   **萌嫂增款 / 减萌嫂款**:
    *   **计算**: 汇总相应类型的 `FinancialAdjustment` 金额。
*   **萌嫂应领款**:
    *   **计算**: `萌嫂保证金(工资) + 加班费 + 5%奖励 + 萌嫂增款 - 减萌嫂款`

---

### **第三部分：育儿嫂合同 (Nanny Contract)**

#### 1. 核心定义与周期逻辑

*   **核心定义**:
    *   **级别 (`employee_level`)**: 育儿嫂的月度基础劳务费，不包含管理费。育儿嫂的管理费要单独计算并缴纳
    *   自动续签(is_monthly_auto_renew)：代表合同结束后，自动按自然月续约（每个月1日到当月最后一天）。
    *   管理费率：10%
    *   管理费： `级别 * 管理费费率`
    *   **客户日薪**: `级别 / 26`
    *   **员工日薪**: `级别 / 26`
*   **账单周期 (`本月合同时间段`)**:
    *   **（已按最新规则重构）** 育儿嫂合同的账单周期严格与**自然月**对齐，并分为三段处理：
        1.  **首月账单**: 从 `合同开始日` 到 `开始日所在月的最后一天`。
            1.  如果是“月签”，则首月计算管理费的时候要注意一个逻辑，计算管理费所用的“ `管理天数`”，要符合 `min(基本劳务天数+1,30)` 的逻辑，也就是说，在`基本劳务天数`不满30天时，“`管理天数`”要比`基本劳务天数` 多1天。
        2.  **中间账单**: 从 `每月1号` 到 `该月最后一天`。
        3.  **末月账单**: 从 `结束日所在月的1号` 到 `合同结束日`。
    *   如果合同在同一个自然月内开始和结束，则只生成一期账单，周期为 `合同开始日` 到 `合同结束日`。
    *   如果合同是自动续约：
        *   首先在从“金数据”同步合同信息时，目前系统根据合同结束日期，自动创建“从合同开始日 ~ 合同结束日”的所有账单。然后要触发一个”自动续签账单检查“，检查的逻辑是：
            *   如果最后一个账单月早与 当前月+11，则自动创建相应账单，直到最后一个账单月 = 当前月+11
        *   其次，创建一个定时任务，在每周1执行，触发相同的”自动续签账单检查“

---

#### 2. 客户账单 (CustomerBill) - 字段与计算方法

*   **级别**:
    *   **来源**: `BaseContract.employee_level`
*   **本月合同时间段**:
    *   **计算**: 根据“账单周期计算逻辑”确定。
*   **被替班天数**:
    *   **计算**: 其他员工代替此阿姨的“替班天数”
*   **实际劳务天数 (`actual_work_days`)**:
    *   **含义**: **(新增)** 运营人员手动设置的、用于计算当月基础劳务费的天数。此值为最高优先级。
    *   **来源**: `CustomerBill.actual_work_days` (由用户在前端输入)。
    *   **取值范围**: 1-26天。
*   **基本劳务天数**:
    *   **计算**: `min((实际账单周期天数 - 被替班天数), 实际劳务天数)`
*   **加班天数**:
    *   **来源**: `AttendanceRecord.overtime_days`
*   **总劳务天数**:
    *   **计算**: `基本劳务天数 + 加班天数 - 被替班天数` 
*   **基础劳务费**:
    *   **计算**: `员工日薪 * 基本劳务天数`
*   **加班费**:
    *   **计算**: `客户日薪 * 加班天数`
*   **本次交管理费**:
    *   **月签合同**: `级别 * 10%`
    *   **非月签合同 (首月)**: `(级别 * 10% * 完整合同月数) + (级别 * 10% / 30 * 不足月的天数)`
    *   **非月签合同 (非首月)**: `0`
*   **客增加款 / 退客户款**:
    *   **计算**: 汇总 `FinancialAdjustment`。
    *   **末月特殊逻辑**: 对于提前结束的合同，将按提前天数与当月合同天数比例按比例退还管理费。
*   **客应付款**:
    *   **计算**: `基础劳务费 + 加班费 + 本次交管理费 + 客增加款 - 退客户款`

---

#### 3. 员工薪酬 (EmployeePayroll) - 字段与计算方法

*   **实际劳务天数 (`actual_work_days`)**:
    *   **含义**: **(新增)** 与客户账单中的定义同步。
    *   **来源**: `EmployeePayroll.actual_work_days`。
*   **基本劳务天数**:
    *   **计算**: `min((实际周期天数 - 被替班天数), 实际劳务天数)`
*   **加班天数**:
    *   **来源**: `AttendanceRecord.overtime_days`
*   **被替班天数**:
    *   **计算**: 其他员工代替此阿姨的“替班天数”
*   **总劳务天数**:
    *   **计算**: `基本劳务天数 + 加班天数   `
*   **基础劳务费**:
    *   **计算**: `员工日薪 * 基本劳务天数`
*   **加班费**:
    *   **计算**: `员工日薪 * 加班天数`
*   **首月员工10%费用**:
    *   **含义**: **（已修正）** 员工首月需向公司支付的服务费，但不能超过其当期总收入。
    *   **条件**: 仅在第一个账单周期计算。
    *   **计算**: `min( (基础劳务费 + 加班费 + 萌嫂增款 - 减萌嫂款), 级别 * 10% )` (作为一笔减款项)。
*   **萌嫂增款 / 减萌嫂款**:
    *   **计算**: 汇总 `FinancialAdjustment`。
*   **萌嫂应领款**:
    *   **计算**: `基础劳务费 + 加班费 - 首月员工10%费用 + 萌嫂增款 - 减萌嫂款`。

### **第四部分：育儿嫂试工合同 (Nanny Trial Contract)**

#### 1. 核心定义与生命周期

*   **核心定义**:
    *   一种短期的、用于评估服务人员是否合适的特殊育儿嫂合同。
    *   **试工天数**: `合同结束日 - 合同开始日`。
    *   介绍费：大部分试工合同中是明确有“介绍费”的，
    *   管理费：`试工人员级别 * 10% / 30 * 实际试工天数`
        *   如果有“介绍费”那么绝大多数情况下不收取“管理费”，除非在“其他内容”即合同结构中的(field_18)中有类似“管理费”字样。这时，在“试工失败”时要收取管理费，但是退还介绍费。
        *   如果没有“介绍费”，则都是按“管理费”收取。
*   **生命周期**:
    *   **试工中 (`trial_active`)**: 合同创建后的默认状态。在此状态下，合同**不产生**任何账单或薪酬单。
    *   **试工成功 (`trial_succeeded`)**: 运营人员手动确认。此状态为最终状态，合同**不产生**任何账单或薪酬单。后续费用由新签订的正式合同承担。
    *   **试工失败 (`terminated`)**: 运营人员手动确认。这是唯一会产生费用的状态，合同会进入结算流程。
        *   实际试工天数 = `试工结束日 - 试工开始日`
        *   "试工"基础劳务费= `试工人员级别/26 * 实际试工天数`
        *   如果 `介绍费>0` 并且`合同备注中不包含“管理费"字样` 	不产生任何管理费。客户应付款 = `试工基础劳务费`
        *   如果 `介绍费 = 0 或空` ，试工账单中产生“管理费” = `试工人员级别 * 10% / 30 * (实际试工天数+1) 。  `客户应付款=`试工劳务费 + 管理费`
            *   如果 `介绍费 > 0` 并且 `合同备注中包含“管理费”字样` 试工账单中产生“管理费”  = `试工人员级别 * 10% / 30 * (实际试工天数+ 1)` 。以及“退还介绍费” = `介绍费 - 管理费。  `  客户应付款 = `试工劳务费 + 管理费 - 介绍费`

#### 2. 客户账单 (CustomerBill) - 仅在“试工失败”时生成

*   **级别**:
    *   **来源**: `BaseContract.employee_level`
*   **本月合同时间段**:
    *   **计算**: `合同开始日` ~ `合同结束日` (即试工周期)。
*   **基本劳务天数**:
    *   **计算**: `试工天数`。
*   **加班天数**:
    *   **来源**: `AttendanceRecord.overtime_days` (通常为0)。
*   **基础劳务费**:
    *   **计算**: `(级别 / 26) * 试工天数`。
*   **加班费**:
    *   **计算**: `(级别 / 26) * 加班天数`。
*   **本次交管理费**:
    *   **固定为**: `0`。
*   **客应付款**:
    *   **计算**: `基础劳务费 + 加班费 + 客增加款 - 退客户款`。

#### 3. 员工薪酬 (EmployeePayroll) - 仅在“试工失败”时生成

*   **基本劳务天数**:
    *   **计算**: `试工天数`。
*   **加班天数**:
    *   **来源**: `AttendanceRecord.overtime_days`。
*   **基础劳务费**:
    *   **计算**: `(级别 / 26) * 试工天数`。
*   **加班费**:
    *   **计算**: `(级别 / 26) * 加班天数`。
*   **首月员工10%费用**:
    *   **逻辑**: 与正式育儿嫂合同**完全一致**。
    *   **计算**: `min( (基础劳务费 + 加班费 + 萌嫂增款 - 减萌嫂款), 级别 * 10% )` (作为一笔减款项)。
*   **萌嫂应领款**:
    *   **计算**: `基础劳务费 + 加班费 - 首月员工10%费用 + 萌嫂增款 - 减萌嫂款`。

### 第五部分：“替班”的业务逻辑：

#### 	“替班”的业务描述：

	首先，替班是没有合同的，是临时产生的，例如A阿姨正在服务，需要临时休假，由B阿姨上户替班。替班细节完全由运营人员来确定，有以下区分：

#### 	替班人员类型

	不论被替班的合同（主合同）是什么类型的合同（月嫂或育儿嫂），<u>**只看替班阿姨（B阿姨）的类型**</u>，由运营人员选择此阿姨是“月嫂”还是“育儿嫂”。也就是是说替班人员的账单逻辑，与被替班的阿姨（A阿姨）合同类型无关！！。

#### 	月嫂：

	管理费率 = `25%` 管理费率由运营人员选择15%或25%，此处默认值是25%。
	
	替班日薪 = `B阿姨的级别 * (1-管理费率) / 26` 
	
	基础服务费 = `B阿姨的级别 * (1-管理费率) / 26 * 替班天数`
	
	管理费 = `B阿姨的级别 * 管理费率 / 26 * 替班天数`
	
	客户应付 = `基础服务费 + 管理费` = 被替班扣款
	
	月嫂工资 = `B阿姨的级别 * (1-管理费率) / 26 * 替班天数` 。

#### 	育儿嫂：

	替班日薪 = `B阿姨的级别 / 26`
	
	合同期内管理费率 = `0`
	
	合同期内替班管理费 = `0`  *（合同期内，合同未结束育儿嫂去替班不收任何管理费，都是给育儿嫂的）*
    
    合同期外管理费率 = `10%`

    合同期外替班管理费 = `B阿姨的级别 * 合同期外管理费率 ` / 30 * 替班天数 ` （和育儿嫂合同一样，按30天计算管理费）
	
	客户应付款 = `B阿姨的级别 / 26 * 替班天数`   = 被替班扣款
	
	育儿嫂工资 = `B阿姨的级别 / 26 * 替班天数` 

#### 	替班加班	

	如果有加班，算法是一样，加班费= `B阿姨级别 / 26 * 加班天数`

#### 	账单调整

##### 	金额调整	

	替班账单生成后，要对A阿姨的相应账单周期中减去相应的 被 `替班天数` 与 `被替班扣款`

##### 	周期调整

	原A阿姨账单（主合同账单）
	
	1. 如果是月嫂：则将对应账单周期的日期向后顺延 `替班天数` ，因为月嫂账单是按26天结算的，这个不能被打破

```
举例，现有月嫂合同主账单周期是2月1日~26日，其中被替班3天（不论替班阿姨是月嫂还是育儿嫂），2月账单向后顺延三天也就是周期变为2月1日~29日，后面如果有账单，后续账单的开始、结束日期也相应自动顺延，以此类推
```

	2. 如果是育儿嫂：则无须调整主账单周期，在主账单中扣除相应的替班天数、替班扣款即可

---

## 第四部分：已完成的后端功能模块说明

我们已经实现了一个功能基本完备的后端。

1.  **services/data_sync_service.py - 数据同步服务**
    - `_load_credentials()`: 从数据库（`llm_api_keys`表）安全地加载并解密金数据API Key和Secret。
    - `get_form_entries()`: 核心API交互函数。使用标准的HTTP Basic Auth，向金数据 V1 API (`jinshuju.net/api/v1`) 发起请求。已实现基于游标(`next`)的自动分页，能够获取一个表单下的所有数据条目。
    - `_get_or_create_personnel_ref()`: 健壮的人员查找/创建函数。遵循“User by phone -> User by name -> ServicePersonnel by phone -> ServicePersonnel by name -> Create new ServicePersonnel”的三步查找逻辑，返回人员类型和ID。
    - `sync_contracts_from_form()`: 主同步逻辑。遍历从API获取的每一条数据，使用嵌套事务来处理单个条目的错误（如唯一性冲突），确保一个条目的失败不会导致整个任务中断。它能正确解析关联字段，清洗数据，并创建对应的 `NannyContract` 或 `MaternityNurseContract` 对象。

2.  **services/billing_engine.py - 核心计算引擎**
    - `calculate_for_month()`: 计算的总入口。它会遍历所有活动合同，并根据类型调用相应的子计算器。
    - `_calculate_maternity_nurse_bill_for_month()`: 月嫂计算逻辑（已按最新规则重构）。它会严格按照“实际上户日期”和26天周期来查找当月需要结算的服务周期。
    - `_process_one_billing_cycle()`: 核心计算函数。当找到一个需要结算的周期后，此函数会被调用。它会查找对应周期的考勤记录，并根据我们最终确认的公式，分别计算客户应付款和员工应领款，然后将结果和计算详情存入 `CustomerBill` 和 `EmployeePayroll` 表。

3.  **api/billing_api.py - 对外API接口**
    - `/sync-contracts` (POST): 触发一个后台Celery任务来执行 `DataSyncService` 的同步逻辑。
    - `/calculate-bills` (POST): 触发一个后台Celery任务来执行 `BillingEngine` 的计算逻辑。
    - `/attendance` (POST): 保存或更新一条考勤记录。
    - `/contracts` (GET): 获取合同列表。
        - 已实现：分页、按客户/员工姓名搜索、按合同类型/状态筛选。
        - 已实现: 默认只显示当前月份处于服务周期内的活动合同。
        - 已实现: 按合同开始日期降序排序。
    - `/summary` (POST): 批量获取账单摘要。接收一个合同ID列表和月份，返回这些合同在该月的应付/应收金额。
    - `/details` (GET): 获取单个合同的单月财务详情。返回一个结构化的对象，包含了与Excel表头对应的所有字段，供前端展示。
    - `/pre-check` (POST): 计算前预检查。接收合同ID列表和月份，返回其中缺少“实际上户日期”的月嫂合同列表。
    - `/contracts/{id}` (PUT): 更新单个合同。目前用于为月嫂合同设置“实际上户日期”。

4.  **tasks.py - 异步任务**
    - 已创建 `sync_all_contracts_task` 和 `calculate_monthly_billing_task`，它们分别作为 `DataSyncService` 和 `BillingEngine` 的异步执行包装器。

---

## 第五部分：后续待办任务

我们已经走完了最艰难的0到1。你的任务是基于现有成果，完成从1到100的精细化开发。

1.  **【最高优先级】实现育儿嫂试工合同与统一的合同终止功能**:——[已完成]
    
    *   **目标**:引入“育儿嫂试工合同”类型，并创建一个统一的、健壮的合同终止流程，该流程能同时处理月嫂、育儿嫂合同的提前终止，以及育儿嫂试工合同的“失败”确认。
    *   **数据与同步**:
        *   **模型 (`models.py`)**: 在 `BaseContract` 中增加 `'nanny_trial'` 类型和 `'trial_active'`, `'trial_succeeded'` 状态。创建`NannyTrialContract` 子类。
        *   **同步 (`data_sync_service.py`)**: 在 `DataSyncService` 的 `FORM_CONFIGS` 中增加试工合同的配置（包含其独立的 `form_token`），使其能被`sync_all_contracts_task` 任务自动同步，并将初始状态设为 `'trial_active'`。
    *   **统一的终止流程**:
        *   **后端 API (`billing_api.py`)**: 创建一个新的API端点：`POST /api/contracts/<contract_id>/terminate`，接收一个必需的参数 `termination_date`。
        *   **后端逻辑**:
            1.  将合同的 `status` 更新为 `terminated`。
            2.  将合同的 `end_date` (及月嫂的 `expected_offboarding_date`) 更新为 `termination_date`。
            3.  删除所有开始日期在 `termination_date` 之后的无效账单和薪酬单。
            4.  为终止日所在的月份，触发一次强制的月度账单重算任务。
    *   **计费引擎 (`billing_engine.py`)**:
        *   **跳过未决合同**: 计费引擎将跳过所有状态为 `'trial_active'` 和 `'trial_succeeded'` 的合同。
        *   **复用现有逻辑**: 对于被终止的试工合同 (`status='terminated'`)，现有的计费逻辑将能自动为其生成一个**零管理费**的客户账单和一个**扣除服务费**的员工薪酬单。
    *   **前端交互 (`ContractList.jsx`)**:
        *   在合同列表的操作列，为正式合同提供“终止合同”按钮，为试工合同提供“试工失败”按钮。
        *   点击任一按钮，都弹出同一个终止日期确认弹窗。
        *   用户确认后，调用新的 `terminate` 接口，并在成功后刷新列表。
    
1.  **[已完成]实现育儿嫂计费逻辑**:
    - 在 `BillingEngine` 中实现 `_calculate_nanny_bill` 函数。
    - 严格按照本交接文档中描述的自然月、26天工作日基准、加班费、首月10%费等规则进行计算。
2.  **【高优先级】实现替班功能增强与账单周期顺延**:[已完成]
    **业务需求回顾 (基于最新确认):**
    替班的计费逻辑现在严格依赖于**替班人员（B阿姨）的类型**（月嫂或育儿嫂），而非被替班的主合同类型。

    *   **月嫂替班人员的计费规则:**
        *   管理费率：`25%` (或运营人员选择的 `15%`)。
        *   替班日薪：`B阿姨的级别 * (1 - 管理费率) / 26`。
        *   客户应付：`B阿姨的级别 / 26 * 替班天数` (此金额已包含管理费)。
        *   员工工资：`B阿姨的级别 * (1 - 管理费率) / 26 * 替班天数`。
        *   **主合同影响 (月嫂):** 被替班的月嫂主合同，其账单周期需向后顺延 `替班天数`。

    *   **育儿嫂替班人员的计费规则:**
        *   管理费率：`0` (育儿嫂替班不收取管理费)。
        *   替班日薪：`B阿姨的级别 / 26`。
        *   客户应付：`B阿姨的级别 / 26 * 替班天数`。
        *   员工工资：`B阿姨的级别 / 26 * 替班天数`。
        *   **主合同影响 (育儿嫂):** 被替班的育儿嫂主合同，账单周期不变，仅在账单中扣除相应费用。

    **设计方案 (最小改动原则):**

    为了在现有代码基础上实现上述逻辑，我们将分以下三步进行：

    1.  **增强数据模型 (`backend/models.py`)**
        *   **目标:** 为 `SubstituteRecord` 模型添加必要的字段以支持新的替班逻辑。
        *   **操作:** 为 `SubstituteRecord` 模型增加 `substitute_type` 字段 (String, 存储 'maternity_nurse' 或 'nanny')。`management_fee_rate` 字段已存在。
        *   **状态:** **已完成**。`substitute_type` 字段已添加到 `backend/models.py`，并通过 Alembic 迁移成功应用到数据库。

    2.  **修改替班账单的计算逻辑 (`backend/services/billing_engine.py`)**
        *   **目标:** 根据替班人员类型，在 `_calculate_substitute_details` 函数中应用不同的计费公式。
        *   **操作:** 在 `_calculate_substitute_details` 函数内部，增加 `if/else` 判断，根据 `sub_record.substitute_type` 的值，分别计算客户应付款、管理费和员工工资。
        *   **状态:** **待开始**。

    3.  **处理主合同账单周期的顺延**
        *   **目标:** 实现月嫂主合同因替班而导致的账单周期自动顺延。
        *   **操作:** 在创建 `SubstituteRecord` 的 API 接口（可能在 `backend/api/billing_api.py`）中，当主合同为月嫂类型时，查询并更新其后续所有未支付账单的 `cycle_start_date` 和 `cycle_end_date`。
        *   **状态:** **待开始**。
3.  **【高优先级】增加终止合同多功能：**[已完成]
    
    1.  由于实际业务中，没有“终止”合同的操作，尤其是在“月签”自动续签的合同中，并没有“终止”的这个操作。
    2.  因此在运营人员查看账单详情或者合同详情的时候需要增加一个按钮“终止合同”，点击后弹出“确认终止日期”的弹窗，此处默认的是合同原本的终止日期，提示用户，是否按合同完成日终止合同？用户可以自行选择日期来终止合同。
    3.  终止合同后，要根据合同的终止日来判断是否要重新计算账单，同时删除已生成的后续月份账单
        1.  如果终止日 = 合同结束日，则不用调整任何账单
        2.  如果终止日 早于 合同结束日，怎结最后一个月的账单就要调整，减少账单服务周期（根据终止日来进行计算）
        3.  如果终止日 晚于 合同结束日，则在当前账单的基础上 生成一个新账单，账单服务周期为合同结束日  ~ 终止日。
    
4.  **【低优先级】仪表盘统计**:
    - 控制台展示，需要设计一个运营人员查看的展示板。请查看我的所有代码，来规划设计一个展示板，用来给运营人员、ceo查看当前系统的核心业务数据。
    - 在财务仪表盘顶部增加统计卡片，显示当月的总应收、总应付、总利润等关键指标。
    - 统计管理费、介绍费
5.  补充功能
    1.  在月嫂账单中，小概率事件会在26天的账单周期中会休息一天，但是账单周期中出勤天数至少是26天，因此会存在运营人员手动修改账单结束日，将本账单周期的结束日向后延x天。因此，如果有后续账单的话，后续账单的周期都会因此而顺延，因此需要重新更新此后的账单。


---

## 第六部分：前端页面设计要求

为以下两个关键页面设计线框图或直接输出HTML代码。

**技术约束:**

- 使用 HTML 和 Tailwind CSS (通过 CDN 引用: `<script src="https://cdn.tailwindcss.com"></script>`)。
- 使用 Material Icons 或 Font Awesome 作为图标 (通过 CDN 引用)
- 页面必须是响应式的。
- 包含轻微的交互效果，如按钮悬停效果。



# 新需求：

 	1. 对于加班、替班、出勤，都会有x.x天的问题，比如2天4小时这种情况，因此为了方便操作，还需要在天数的计步器后选择小时数。**[已完成]**
 	2. 对于“替班”，往往需要精确到小时和分钟，其中分钟笼统的步长为半小时即可，前端页面上进行操作，选择小时及分钟时，只需要选，x:30 或x:00即可。**[已完成]**
 	3. 在“添加替班”时，在弹窗中的所有字段都是必填的，员工、替班开始时间、结束时间、替班类型等。【**已完成】**
 	4. 在为客户开发票时有可能本月只开一部分，剩下的放在下个月去开，因此需要在界面中支持显示“剩余开票金额“。只有在”剩余开票金额“不为0时才需要显示。
 	5. 对于育儿嫂最后一个月的账单，有可能需要“人工延长”，这种情况对应的是合同到期了，但是客户要求育儿嫂再多服务几天，因此就会产生“延长服务“的业务需求，延长到天数要按天数付管理费以及育儿嫂的工资。因此需要在最后一期账单的“劳务时间段”中有一个“延长服务”的功能，[已完成]
 	6. 添加“替班记录”后，当前账单详情要即刻显示被替班天数、被替班扣款等，并自动重新计算相应的总额，而不需要用户重新刷新或重新打开账单详情窗口。**[已完成]**
 7. 替班记录中 显示精确的起止时间，精确到小时分钟。**[已完成]**
 	8. 增加批量设置为已付款、已领款的功能，在批量更新的弹窗中可以逐个填写“打款日期、打款渠道/备注”与“领款日期、领款渠道备注”，并对日期、备注分别增加同上按钮，点击后复制上一行的日期与备注即可
 	9. 合同详情中显示“管理费” `management_fee_amount` 字段。增加”介绍费“字段，并且可以编辑”介绍费“ `introduction_fee` 。 合同详情中还需要有一个备注，由运营人员来管理和填写，可以和现有note是同一个字段，但不能修改合同中原有的备注（从金数据同步过来时的备注），因此这个备注只能在后面追加，并且对追加内容进行修改。[已完成]
 	9. 对于“月签自动续签”的合同，实际上每一个收取的“管理费”是“下个月的管理费”，相当于提前收取了整月（30天）的管理费，因此对于“自动续签”的合同，终止时也要按比例退还提前按整月收取的管理费——**【暂不处理由人工手动处理此业务】**
 	9. 由于有的合同开始日临近月底，因此一般业务上会将某些本月账单（账单天数较少的账单）手动合并到下个月，与下个月整月的或者天数较多的账单合并一起找客户收取一次费用。在”客户是否“打款处可将此费用顺延到下一期账单。并且在是否已打款中进行区分（已顺延），并在下一期账单中体现这一笔被顺延的费用。**[已完成]**
 	9. "客户账单"中不体现”基础劳务费“、”加班费“、”被替班费用“等这些与员工工资相关的内容，只体现”管理费“、”保证金“等与公司相关的收入。**[已完成]**
 	9. 在计算员工首月10%费用时，不需要现有的对比逻辑，这种对比是少数。——【暂不处理，由人工处理即可】
 	9. 育儿嫂替班，有少数情况可能会收取管理费20%，大部分的时候没有。

---
## 功能设计：高级发票管理与动态余额追踪 (v4.0)

### 1. 核心需求与目标 (The Why)

*   **背景:** 财务流程中，一张客户账单的应付金额可能不会通过单张发票一次性结清。业务上存在将一张账单的金额分摊到多张发票（可能跨越不同时间）进行开具的场景，且此开票需求是合同级别的。
*   **核心痛点:**
    1.  无法在合同层面统一管理开票策略，需逐月设置，容易出错。
    2.  无法直观看到全局（尤其是账单列表页）的待开票情况。
    3.  历史月份未开票的金额无法自动、准确地累积到当前月份，需要人工追溯，极易遗漏。
*   **全局策略:** 引入“合同级开票策略”，在合同层面设置唯一的、全局生效的开票开关。
*   **目标:**
    1.  **全局可视:** 在账单列表页，一目了然地识别出所有存在“剩余待开票金额”的账单。
    2.  **策略继承:** 确保新创建和自动续签的合同，能自动继承其父合同的开票策略。
    3.  **动态累积:** 建立一个实时的、动态的余额计算模型，准确地将所有历史欠票金额累积到当前账期，无需手动结转。

### 2. 功能需求详述 (The What)

#### Feature 1: 合同级开票策略 (数据与交互)

*   **数据库模型 (`models.py`):**
    *   在主合同模型 (`BaseContract` 或各子类合同模型) 中，增加一个布尔类型的字段：
        ```python
        # 示例:
        invoice_needed = db.Column(db.Boolean, nullable=False, default=False, server_default='false', comment="本合同是否需要开票")
        ```
    *   **待办:**
        1.  执行数据库迁移 (`flask db migrate` 和 `upgrade`)。
        2.  (可选) 编写数据订正脚本，根据存量账单数据，为历史合同填充此字段的默认值。
        3.  (可选) 将 `CustomerBill.invoice_needed` 字段标记为待废弃。

*   **前端交互 (`合同详情页`):**
    *   提供一个明确的开关（Switch），标签为 **“本合同需要开票”**。
    *   用户操作此开关并保存后，更新 `Contract.invoice_needed` 字段，作为全局开票策略的唯一来源。

#### Feature 2: 策略的自动继承 (自动化流程)

*   **初始账单生成:**
    *   在创建新合同时，其下所有账单的开票行为将完全由 `Contract.invoice_needed` 决定。
*   **自动续签任务:**
    *   修改每月执行的自动续签定时任务。
    *   在生成新的续签合同时，必须读取原始合同的 `invoice_needed` 值，并将其赋给新合同，确保策略的无缝继承。

#### Feature 3: 动态余额计算引擎 (实时计算)

*   **核心理念:** 从“推送结转”转变为“实时拉取”。当查看任何一个月的账单时，系统都实时地、动态地“拉取”并计算所有历史月份累积下来的未开票余额。
*   **关键概念:**
    *   **历史累计欠票 (`Total Carried-Forward`):** 查看 N 月账单时，系统实时计算的从第 1 个月到第 N-1 个月所有账单的“剩余待开票”金额的总和。
    *   **本期应开票总额 (`Total Invoiceable Amount`):** `本期费用 + 历史累计欠票`。
*   **后端实现 (`billing_engine.py` 或类似服务):**
    *   创建一个核心函数 `calculate_invoice_balance(target_bill)`。
    *   **逻辑:**
        1.  获取目标账单的合同及所有比它早的“兄弟”账单。
        2.  遍历所有历史账单，计算 `(历史账单总费用 - 该账单已开票总额)`，将所有正数的差额累加，得到 `total_carried_forward`。
        3.  返回一个包含 `current_period_charges`, `total_carried_forward`, `total_invoiceable_amount` 的结构化数据。
    *   **优势:** 此方案无需修改 `FinancialAdjustment` 模型，逻辑内聚，且能完美处理“跨期补开票”的场景，数据永远保持实时一致。

#### Feature 4: 全局状态可视化 (前端展示)

*   **账单列表页 (`GET /api/contracts/<id>/bills`):**
    *   **API增强:** 后端接口在返回账单列表时，对每一条需要开票的账单，都调用计算引擎算出其`total_remaining_un_invoiced` (截至本期的总待开票额)。
    *   **前端显示:**
        *   新增“开票状态”列。
        *   若 `Contract.invoice_needed` 为 `False`，显示“无需开票”。
        *   若为 `True` 且 `total_remaining_un_invoiced > 0`，则显示橙色金额 **`总计待开: ¥[金额]`**。
        *   若为 `True` 且金额为 `0`，则显示“已结清”。

*   **财务管理弹窗 (`InvoiceDetailsDialog.jsx`)**:
    *   **API增强:** `GET /billing/details` 接口需调用计算引擎，返回详细的金额分类。
    *   **前端显示 (顶部信息区):**
        *   **本期费用:** `¥ [current_period_charges]`
        *   **历史累计欠票:** `+ ¥ [total_carried_forward]` (仅在大于0时显示)
        *   **本期应开票总额:** `¥ [total_invoiceable_amount]` (加粗)
        *   **本期已开票总额:** `¥ [sum of invoices for this bill]`
        *   **当前总剩余待开票:** `¥ [difference]` (突出显示)

### 3. 实施路径建议

1.  **数据库修改 (第一步):** 在 `Contract` 模型中添加 `invoice_needed` 字段，并执行数据库迁移。
2.  **后端逻辑修改 (第二步):**
    *   修改**自动续签**的定时任务，确保新合同能继承 `invoice_needed` 状态。
    *   在 `BillingEngine` 中实现**动态计算服务** `calculate_invoice_balance`。
3.  **API 修改 (第三步):**
    *   调整所有与账单和发票相关的 API (列表、详情)，使其判断逻辑基于 `Contract.invoice_needed`，并调用计算服务返回新数据。
4.  **前端修改 (第四步):**
    *   在合同编辑页面加入全局的“是否需要开票”开关。
    *   根据 API 返回的新数据结构，更新账单列表和财务管理弹窗的显示逻辑。

---

## 功能设计：高级发票管理 (v5.0 简化版 - 最终方案)

### 1. 核心理念：账单级独立控制

经过讨论，我们认识到发票业务具有高度的灵活性和不确定性。因此，最终方案将赋予运营人员最大的手动控制权，而不是依赖僵化的全局规则。

*   **唯一权威来源:** `CustomerBill.invoice_needed` (布尔类型字段) 是决定一张账单是否参与发票计算的**唯一、最终的依据**。
*   **合同级策略:** `BaseContract.invoice_needed` 字段在数据库中保留，但当前所有业务逻辑**暂时忽略**它。它仅为未来的扩展预留可能性。
*   **默认状态:** 所有新生成的账单，其 `invoice_needed` 字段默认为 `False` (无需开票)，完全由运营人员后续手动开启。

### 2. 功能设计详述

#### Feature 1: 数据模型与状态

*   **`CustomerBill.invoice_needed`:**
    *   **状态:** **已确认**。此字段已存在于数据库中，无需再次迁移。
    *   **功能:** 作为控制单个账单是否参与发票计算的**权威开关**。

#### Feature 2: 动态余额计算引擎 (核心)

*   **核心函数:** `calculate_invoice_balance(target_bill)`，位于 `billing_engine.py`。
*   **核心逻辑:**
    1.  获取 `target_bill` 的合同及所有**早于**它的历史账单。
    2.  初始化 `total_carried_forward = 0`。
    3.  遍历这些历史账单：
        a.  **检查开关:** **只有当该历史账单的 `invoice_needed` 字段为 `True` 时**，才将其纳入计算。
        b.  对于需要计算的账单，累加其欠票金额 (`该账单总费用 - 该账单已开票总额`) 到 `total_carried_forward`。
        c.  累计欠票额要记录明细 mm月欠票¥ xxxx.xx 元，便于前端通过 `log_extras`的形式展示。
    4.  返回一个包含 `current_period_charges`, `total_carried_forward`, `total_invoiceable_amount` 的结构化数据。
*   **优势:** 此方案具有**自愈性**和**实时一致性**。无论用户何时、以何种顺序打开或关闭任何账单的开票开关，后续账单的“历史累计欠票”总能被实时、准确地计算出来，完美解决了跨期补开票等复杂场景。

#### Feature 3: 前端交互与展示

*   **账单列表页 (`/contracts/<id>`)**
    *   **API (`GET /api/contracts/<id>/bills`):** 后端需增强此接口。对于列表中的每一张账单，都调用 `calculate_invoice_balance` 计算出其**截至本期的总待开票额** (`total_remaining_un_invoiced`)，并随列表返回。
    *   **前端显示:**
        *   新增“开票状态”列。
        *   如果账单的 `invoice_needed` 为 `False`，显示“无需开票”。
        *   如果 `invoice_needed` 为 `True` 且 `total_remaining_un_invoiced > 0`，则显示橙色金额 **`累计待开: ¥[金额]`**。
        *   如果 `invoice_needed` 为 `True` 且金额为 `0`，则显示“已结清”。

*   **财务管理弹窗 (`FinancialManagementModal.jsx`)**
    *   **API (`GET /billing/details`):** 接口需调用计算引擎，返回详细的金额分类。
    *   **前端显示:**
        *   在弹窗顶部增加一个独立的、权威的开关：“**本期账单需要开票**”，直接绑定 `CustomerBill.invoice_needed` 字段。
        *   当开关为**开启**时，显示完整的发票管理模块，其顶部信息区应包含：
            *   **本期费用:** `¥ [current_period_charges]`
            *   **历史累计欠票:** `+ ¥ [total_carried_forward]` (仅在大于0时显示)。使用与“ 账单计算日志 `log_extras` ”相同的方法记录显示历史欠票明细： mm月欠票¥ xxxx.xx元
            *   **本期应开票总额:** `¥ [total_invoiceable_amount]` (加粗)
            *   **本期已开票总额:** `¥ [sum of invoices for this bill]`
            *   **剩余待开票:** `¥ [difference]` (突出显示)
        *   当开关为**关闭**时，整个发票模块被禁用或收起。

### 3. 实施路径

1.  **后端核心计算 (第一步):** 在 `billing_engine.py` 中实现 `calculate_invoice_balance` 函数。
2.  **后端 API 修改 (第二步):** 修改账单列表和账单详情的 API，集成上述计算逻辑，并返回新的数据结构。
3.  **前端界面修改 (第三步):** 修改合同详情页的账单列表和财务管理弹窗，以实现新的显示和交互逻辑。


## 功能设计：高级发票管理 (v6.0 - 已实现方案)

### 1. 核心理念

- **发票与管理费挂钩:** 系统的所有发票相关计算（应开票额、历史欠票）都严格基于账单中的“管理费”，而非账单总额。
- **一账单对多发票:** 每张客户账单 (`CustomerBill`) 都可以关联多条独立的发票记录 (`InvoiceRecord`)。发票记录是已开票金额的唯一真实来源。
- **账单级独立控制:** 每张账单通过其自身的 `invoice_needed` 布尔字段来控制是否参与发票流程。
- **智能状态同步:** 如果存在历史欠票，后续账单会自动在UI上标记为需要开票，但此状态由用户在前端手动操作后，才会最终持久化到数据库。
- **精确的净额结算:** 历史欠票的计算采用净额算法，即后续月份的多开票额可以抵扣之前月份的欠票。
- **替班账单隔离:** 替班账单拥有独立的发票生命周期，不参与主合同的历史欠票计算。

### 2. 数据模型 (`models.py`)

- **`CustomerBill`**:
    - `invoice_needed: Boolean` - 控制本账单是否需要开票的**主开关**。
    - `invoices` - 指向 `InvoiceRecord` 的一对多关系，可以访问此账单下的所有发票。

- **`InvoiceRecord`**:
    - `customer_bill_id` - 指向 `CustomerBill` 的外键，确立了与特定账单的从属关系。
    - `invoice_number: String` - 发票号码。
    - `amount: Numeric` - 发票金额。
    - `issue_date: Date` - 开票日期。
    - `notes: Text` - 备注。

### 3. 核心计算逻辑 (`billing_engine.py:calculate_invoice_balance`)

- **输入:** 目标账单ID (`target_bill_id`)。
- **处理流程:**
    1.  **判断账单类型:** 首先检查目标账单是否为替班账单 (`is_substitute_bill`)。
        - **若是**，则跳过所有历史计算，历史欠票永远为0。
        - **若否**，则继续执行主账单的计算逻辑。
    2.  **计算历史净值:** 获取所有早于当前账单的**主账单**。
        - 计算这些历史账单的**累计应开管理费总额**。
        - 计算这些历史账单的**累计已开发票总额**（通过加总所有关联的 `InvoiceRecord` 金额）。
    3.  **得出历史欠票:** `历史累计欠票 = 累计应开管理费总额 - 累计已开发票总额`。如果结果为负（多开了），则历史欠票计为0。
    4.  **生成返回数据:**
        - **`current_period_charges`**: 当前账单的管理费。
        - **`total_carried_forward`**: 上一步算出的精确历史累计欠票。
        - **`total_invoiceable_amount`**: `本期管理费 + 历史累计欠票`。
        - **`invoiced_this_period`**: 当前账单已开具的发票总额。
        - **`remaining_un_invoiced`**: `应开总额 - 已开总额`。
        - **`invoice_records`**: 当前账单关联的所有发票记录的列表。
        - **`carried_forward_breakdown`**: 仅在 `total_carried_forward > 0` 时生成，包含产生欠费的历史月份及金额。
        - **`auto_invoice_needed`**: 一个布尔标志，用于通知前端UI是否应该自动打开“需要开票”的开关（`target_bill.invoice_needed` 或 `total_carried_forward > 0`）。

### 4. 前端交互 (`FinancialManagementModal.jsx`)

- **发票状态区:** 清晰地展示“本期管理费”、“历史累计欠票”、“本期已开票”和“剩余待开”四个核心指标。
- **历史欠票明细:** 当存在历史欠票时，在金额旁通过悬浮提示框展示欠款来源的月份和金额。
- **发票管理弹窗:** 提供一个独立的弹窗 (`InvoiceDetailsDialog.jsx`) 来管理一个账单下的所有发票记录，支持增、删、改操作。
- **智能开关:** “本账单需要开票”的开关状态会根据后端的 `auto_invoice_needed` 标志进行初始化，同时也完全支持用户手动修改。

---
## 新增功能设计：保证金转移

### 1. 核心目标

为合同结束时系统自动生成的“保证金退款”财务调整项，增加一个“转移”功能。允许运营人员将这笔款项从当前已结束的合同，直接转移至客户名下的另一份新合同中，作为新合同的预收款，并确保整个过程在财务记录上清晰、可追溯。

### 2. 后端设计

#### 2.1. 数据模型 (`FinancialAdjustment` Model)

为了实现此功能，我们需要对 `FinancialAdjustment` 模型进行扩展，以便记录转移的关联信息。最理想的方式是利用一个 JSON 类型的字段来存储这些元数据，这样既灵活又无需修改表结构。我们假定模型中存在一个名为 `details` 的 `JSONB` 字段。

**`details` 字段的使用约定：**

1.  **对于转出的原调整项** (原始的“保证金退款”):
    *   其 `details` 字段将更新为：
        ```json
        {
          "status": "transferred",
          "transferred_to_contract_id": "新合同的UUID",
          "transferred_to_adjustment_id": "新生成的调整项的UUID"
        }
        ```
    *   同时，其 `description` 字段将追加标识，变为：`保证金退款 [已转移至合同: <新合同客户名>]`

2.  **对于转入的新调整项** (新生成的“其他合同转移保证金退款”):
    *   其 `details` 字段将记录来源信息：
        ```json
        {
          "status": "transferred_in",
          "transferred_from_contract_id": "原合同的UUID",
          "transferred_from_adjustment_id": "原调整项的UUID"
        }
        ```
    *   其 `description` 字段将固定为：`其他合同转移保证金退款` (前端将根据 `details` 字段渲染出超链接)

#### 2.2. 核心业务逻辑 (`BillingEngine`)

计算引擎在汇总一个账单的财务调整项时，**必须跳过**所有 `details` 字段中 `status` 为 `'transferred'` 的调整项，确保已转出的款项不会被重复计算。

#### 2.3. API 接口设计

我们将创建一个新的 API 接口来执行转移操作。

*   **接口路径**: `POST /api/financial-adjustments/<adjustment_id>/transfer`
*   **URL 参数**:
    *   `adjustment_id` (UUID): 需要被转移的原始“保证金退款”调整项的 ID。
*   **请求体 (Request Body)**:
    ```json
    {
      "destination_contract_id": "目标新合同的UUID"
    }
    ```
*   **后端处理流程**:
    1.  **权限验证**: 检查当前用户是否有权操作。
    2.  **数据校验**:
        *   验证 `adjustment_id` 对应的调整项是否存在，且其描述为“保证金退款”。
        *   验证 `destination_contract_id` 对应的合同是否存在。
        *   验证两个合同是否属于同一个客户。
    3.  **执行转移 (在一个数据库事务中)**:
        a.  锁定并更新**原调整项**的 `description` 和 `details` 字段（如 2.1 节所定义）。
        b.  在**新合同**下，创建一条**新的财务调整项**，`amount` 与原调整项相同，`description` 和 `details` 按约定填充。
        c.  记录操作日志 (`FinancialActivityLog`)。
    4.  **触发重算**: （可选，但推荐）提交事务后，可以异步触发对两个关联合同账单的重算任务，以确保数据同步。
    5.  **返回结果**: 返回成功消息。

### 3. 前端设计

#### 3.1. UI/UX 流程

1.  **触发点**: 在账单详情页的“财务调整”列表中，对于描述为 `保证金退款` 的条目，在其右侧增加一个“**转移**”按钮。
2.  **转移弹窗**:
    *   点击“转移”按钮，弹出一个模态窗口，标题为“转移保证金”。
    *   弹窗内包含一个**合同选择器**（下拉框或带搜索功能的列表），该选择器应**只显示**当前客户名下所有状态为 `active` 的其他合同。
    *   用户选择一个目标合同后，点击“确认转移”按钮。
3.  **交互反馈**:
    *   前端调用 `POST /api/financial-adjustments/.../transfer` 接口。
    *   在请求期间显示加载状态。
    *   成功后，刷新当前账单详情页。原“保证金退款”条目会更新为“已转移”状态。
4.  **链接渲染**:
    *   在渲染财务调整列表时，检查每一项的 `details` 字段。
    *   如果 `details.status` 为 `transferred_in`，则将该项的描述 `其他合同转移保证金退款` 中的 `其他合同` 渲染成一个超链接，`href` 指向 `/contracts/<details.transferred_from_contract_id>`，并设置 `target="_blank"`。

### 4. 开发步骤

1.  **后端-准备工作**:
    *   检查 `FinancialAdjustment` 模型，确认是否存在 `details: JSONB` 字段。若无，则添加并执行数据库迁移。
2.  **后端-核心逻辑**:
    *   在 `billing_engine.py` 中修改计算逻辑，使其在加总调整项时，排除 `details.status == 'transferred'` 的条目。
3.  **后端-API开发**:
    *   在 `billing_api.py` (或新建的 `adjustment_api.py`) 中，实现 `POST /api/financial-adjustments/<adjustment_id>/transfer` 接口的全部逻辑。
4.  **前端-UI开发**:
    *   在账单详情页的财务调整项组件中，根据描述条件渲染“转移”按钮。
    *   创建“转移保证金”弹窗组件，包含客户合同的搜索与选择功能。
5.  **前端-逻辑与渲染**:
    *   实现弹窗的确认逻辑，调用后端API。
    *   修改财务调整列表的渲染逻辑，使其能根据 `details` 字段动态生成合同详情页的链接。
6.  **联调与测试**:
    *   进行端到端测试，确保转移操作的正确性、数据一致性以及链接跳转的有效性。



---
## 新增功能设计：创建虚拟合同

### 1. 核心目标 (The Why)

在实际业务中，部分客户可能通过线下或其他非“金数据”渠道签约，导致系统中缺少这些合同，从而无法为其生成账单和进行后续的财务管理。本功能旨在为运营人员提供一个内部接口，手动在系统中创建“虚拟合同”，使其能与通过“金数据”同步的合同一样，被纳入完整的计费和管理流程。

### 2. 后端设计 (Backend)

#### 2.1. API 接口设计

我们将创建一个新的 API 接口来处理虚拟合同的创建。

*   **接口路径**: `POST /api/contracts/virtual`
*   **权限**: 管理员 (`@admin_required`)
*   **请求体 (Request Body)**:{"contract_type": "nanny", // "nanny", "maternity_nurse", or "nanny_trial""customer_name": "张三", // 支持查找或创建"contact_person": "张三丰","employee_name": "王阿姨", // 支持查找或创建"employee_level": 12800,"start_date": "2025-09-01","end_date": "2026-08-31","notes": "这是一个虚拟合同的备注。",// 月嫂合同特有字段"provisional_start_date": "2025-08-25", // <-- 新增：预产期"security_deposit_paid": 15000,"management_fee_amount": 2200,// 育儿嫂合同特有字段"is_monthly_auto_renew": false,// ... 其他所有合同模型中需要的字段}
*   **成功响应 (201)**:{"message": "虚拟合同创建成功，已提交后台任务生成账单。","contract_id": "新创建的合同UUID"}

#### 2.2. 核心业务逻辑

1.  **复用人员查找逻辑**:
    *   在 `billing_api.py` 或一个新建的 `services/personnel_service.py` 中，创建一个可被多处调用的辅助函数，如`get_or_create_personnel(name, phone=None)`。
    *   此函数的逻辑必须与 `data_sync_service.py` 中的 `_get_or_create_personnel_ref` 完全一致，遵循“User by name ->ServicePersonnel by name -> Create new ServicePersonnel”的查找/创建顺序，最终返回人员的ID和类型。

2.  **合同创建主流程**:
    *   接口接收到请求后，首先调用上述辅助函数处理 `employee_name`，获取员工ID。
    *   根据请求中的 `contract_type`，实例化正确的合同模型（`NannyContract`, `MaternityNurseContract` 等）。
    *   为合同对象的所有字段（`customer_name`, `employee_level`, `start_date` 等）赋值。**对于月嫂合同，需要额外处理 `provisional_start_date` 字段。**
    *   为合同对象增加一个 `source` 字段（如果模型中没有，需要添加），并赋值为 `'virtual'`，以作区分。
    *   将新创建的合同对象存入数据库并提交事务。

3.  **触发账单生成**:
    *   在合同成功保存后，必须以新创建的 `contract_id` 为参数，调用并触发一个异步的 `generate_all_bills_for_contract_task` 任务。
    *   这是确保虚拟合同能被正常使用的关键一步，可以保证其所有周期的账单都被预创建。

#### 2.3. 辅助接口设计

为了支持前端的搜索功能，需要提供以下接口：

*   **员工搜索**: `GET /api/personnel/search?q=<query>`
    *   根据查询参数 `q`，在 `User` 和 `ServicePersonnel` 表中模糊搜索 `name` 和 `name_pinyin` 字段。
    *   返回一个包含 `id` 和 `name` 的对象列表。
*   **客户搜索**: `GET /api/customers/search?q=<query>`  **<-- 新增**
    *   根据查询参数 `q`，在 `BaseContract` 表中模糊搜索 `customer_name` 和 `customer_name_pinyin` 字段。
    *   返回一个去重后的客户姓名字符串列表 (`DISTINCT customer_name`)。

### 3. 前端设计 (Frontend)

#### 3.1. 入口与界面

*   **入口**: 在合同列表页 (`/contracts`) 的操作区（如搜索框旁边），新增一个“**新增虚拟合同**”按钮。
*   **界面**: 点击按钮后，弹出一个全屏对话框（`Dialog`），其中包含一个用于创建虚拟合同的表单。

#### 3.2. 表单设计与交互

*   **合同类型**: 表单的第一个字段是“合同类型”下拉框。当用户切换类型时，表单下方应动态显示或隐藏该类型专属的字段。**特别是，选中“月嫂”时，需要显示“预产期”字段。**
*   **客户与员工选择**: “客户名称”和“员工名称”字段都应为“自动补全搜索框”（`Autocomplete`）。
    *   用户输入时，分别调用对应的后端搜索接口 (`/api/customers/search` 和 `/api/personnel/search`) 获取匹配列表。
    *   如果搜索结果为空，下拉列表中应出现一个“创建新...：[用户输入的值]”的选项，允许运营人员在提交时创建新的实体。
*   **提交与反馈**:表单提供“取消”和“确认创建”按钮。“确认创建”按钮在所有必填项被填写前应为禁用状态。点击后，按钮显示加载状态，直到收到后端响应。成功后，显示成功消息，自动关闭弹窗，并刷新合同列表。

### 4. 开发步骤

1.  **后端**: 在 `BaseContract` 和 `MaternityNurseContract` 模型中确认 `source` 和 `provisional_start_date`字段存在，如无则添加并执行数据库迁移。
2.  **后端**: 实现可复用的 `get_or_create_personnel` 辅助函数以及 `GET /api/personnel/search` 和 `GET /api/customers/search`搜索接口。
3.  **后端**: 实现核心的 `POST /api/contracts/virtual` 接口，包含完整的创建和触发后台任务的逻辑。
4.  **前端**: 创建“新增虚拟合同”的表单组件 `CreateVirtualContractModal.jsx`。
5.  **前端**: 在表单组件中，实现动态字段显示（包括“预产期”），并为“客户”和“员工”字段实现带搜索、创建功能的自动补全输入框。
6.  **前端**: 在合同列表页添加“新增”按钮，并完成打开弹窗、调用API、刷新列表的全部交互。---

---

#   功能设计：外部替班合同 (v11.0)

### 1. 核心目标 (The Why)

  在现有业务中，除了为本公司签约在岗的员工安排替班（“内部替班”）之外，还存在一种为非本公司员工提
  供临时替班服务的业务场景。这种服务本质上是一个独立的、与公司现有合同无关的短期服务协议。

  当前系统无法处理这种没有“主合同”的替班需求。本功能旨在通过引入一种新的、独立的“外部替班合同”
  ，将此类业务纳入系统，实现对其服务的计费、支付和管理的闭环。

### 2. 核心理念 (The Core Concept)

  我们拒绝采用“打补丁”的方式（如修改现有替班记录，允许其主合同为空），因为那会污染数据模型的语
  义，制造混乱。

  我们选择的方案是：将“外部替班”视为一种全新的、一等公民的合同类型。

   * 模型独立: 我们将创建一个新的合同模型 ExternalSubstitutionContract，它继承自 BaseContract。
   * 逻辑内聚:
     所有与此业务相关的特殊规则（如按天计费、20%管理费率）都将被封装在为它量身定制的计费函数中。
   * 设施复用: 这种新合同将无缝地复用系统中所有现存的、成熟的基础设施，包括合同管理、账单生成、
     财务弹窗、收付款记录等。

  这个设计保证了概念的清晰、逻辑的隔离和未来的可扩展性。

### 3. 功能需求详述 (The What)

####   3.1. 数据模型 (models.py)

   1. 新建 `ExternalSubstitutionContract` 模型:
       * 在 models.py 中，创建一个新的类 ExternalSubstitutionContract，并使其继承自
         BaseContract。
       * 为其 __mapper_args__ 指定 polymorphic_identity 为 'external_substitution'。
   2. 新增专属字段:
       * 为该模型增加一个专属字段 management_fee_rate，类型为 db.Numeric(5, 2)，并设置默认值为
         0.20，用于记录管理费率。
   3. 数据库迁移:
       * 在模型修改完成后，必须运行 flask db migrate 和 flask db upgrade
         命令，以将新的表结构应用到数据库。

####   3.2. 计费规则 (Billing Rules)

  对于“外部替班合同”，系统将生成一期唯一的账单，其计费规则如下：

   1. 服务天数 (`service_days`):
       * 根据合同的起止时间（精确到小时和分钟）进行计算。
       * 计算公式: (合同结束时间 - 合同开始时间).total_seconds() / 86400。
   2. 客户应付总额 (`customer_payable`):
       * 计算公式: 员工级别 / 26 * 服务天数。
   3. 管理费 (`management_fee`):
       * 计算公式: 客户应付总额 * 管理费率 (其中管理费率默认为20%，可修改)。
   4. 员工应发工资 (`employee_payout`):
       * 计算公式: 客户应付总额 - 管理费。

####   3.3. 用户界面与交互 (UI/UX)

   1. 创建入口:
       * 复用现有的“新增虚拟合同”功能 (CreateVirtualContractModal.jsx)。
   2. 修改创建弹窗:
       * 在“合同类型”下拉菜单中，增加一个新选项：“外部替班合同”。
       * 当用户选择此类型时，表单将动态调整，仅显示与此业务相关的字段：
           * 客户名称
           * 服务人员
           * 服务开始时间 (日期+时间选择器)
           * 服务结束时间 (日期+时间选择器)
           * 员工级别
           * 管理费率 (数字输入框，默认值为 20%)
           * 备注

### 4. 后端实现路径 (The How)

   1. 计费引擎 (`billing_engine.py`):
       * 在 BillingEngine 类中，创建一个新的私有方法
         _calculate_external_substitution_details(...)。
       * 此方法将完整实现 3.2 节中定义的所有计费规则。
       * 修改 calculate_for_month 函数，增加一个 elif contract.type == 'external_substitution':
         分支，调用上述新创建的计算方法。
   2. 合同创建接口 (`billing_api.py`):
       * 修改现有的 POST /api/contracts/virtual 接口。
       * 在其中增加一个 elif contract_type == 'external_substitution': 分支，用于实例化新的
         ExternalSubstitutionContract 模型并保存到数据库。

### 5. 开发步骤 (Implementation Steps)

   1. 第一步 (模型): 修改 backend/models.py，添加新模型类，并执行数据库迁移。
   2. 第二步 (计费): 在 backend/services/billing_engine.py 中，实现新的计费函数。
   3. 第三步 (接口): 在 backend/api/billing_api.py 中，更新虚拟合同创建接口，使其支持新类型。
   4. 第四步 (前端): 修改
      frontend/src/components/CreateVirtualContractModal.jsx，在UI上支持新合同的创建。
   5. 第五步 (联调): 进行端到端的功能测试。


# 功能设计文档：可修改的“自动续签”状态

## 1. 需求概述

  在“合同详情”页面，允许用户修改“是否自动月签”这一属性。此操作会触发相应
  的后台账单处理逻辑，确保合同和账单数据的一致性。

## 2. 前端设计 (ContractDetail.jsx)

###   2.1. UI变更

   - 在“合同详情”页面的“是否自动月签”字段旁边，将原有的只读文本“是/否”替换
     为一个交互式的开关（Switch）组件。
   - 只有当合同状态为 active (服务中) 且合同类型为 nanny (育儿嫂)
     时，此开关才可用。其他状态下应禁用。

###   2.2. 交互流程

  场景一：关闭“自动续签” (从“是”改为“否”)

   1. 用户点击开关，尝试从“是”切换到“否”。
   2. 阻止开关状态立即变化。弹出一个确认对话框（Dialog）。
   3. 对话框标题为“确认关闭自动续签”，内容提示用户：“关闭自动续签相当于提前
      终止合同，需要您为合同选择一个最终结束日期。”
   4. 对话框中提供一个日期选择器（DatePicker），默认值为今天的日期，允许用户
      设置合同的最终结束日期。
   5. 用户选择日期后，点击“确认终止”按钮。
   6. 前端调用后端的“终止合同”API，并将用户选择的日期作为参数传递。
       - API: POST /contracts/<contract_id>/terminate
       - Payload: { "termination_date": "YYYY-MM-DD" }
   7. 操作成功后，刷新整个页面的数据，用户会看到合同状态变为
      terminated，并且“是否自动月签”的开关变为禁用状态。

  场景二：开启“自动续签” (从“否”改为“是”)

   1. 用户点击开关，尝试从“否”切换到“是”。
   2. 阻止开关状态立即变化。
   3. 前端直接调用新增的“开启自动续签”API。
       - API: POST /contracts/<contract_id>/enable-auto-renew
   4. API调用成功后，开关状态正式变为“是”。同时，页面应显示一个加载提示（loa
      ding
      indicator），并刷新合同的账单列表，用户将能看到未来被延展出来的账单。

##   3. 后端设计 (billing_api.py)

###   3.1. 新增API：开启自动续签

   - Endpoint: POST /contracts/<uuid:contract_id>/enable-auto-renew
   - 功能描述: 为指定的育儿嫂合同开启自动续签，并立即触发一次账单延展。
   - 处理逻辑:
       1. 接收 contract_id，查找对应的 NannyContract 合同。
       2. 前置条件检查: 确认合同状态为 active。如果不是，则返回错误。
       3. 将合同的 is_monthly_auto_renew 字段更新为 true。
       4. 实例化 BillingEngine 服务。
       5. 调用 engine.extend_auto_renew_bills(contract.id)
          方法，执行账单延展逻辑。
       6. 提交数据库事务。
       7. 返回成功响应。

###   3.2. 复用API：终止合同

   - Endpoint: POST /contracts/<uuid:contract_id>/terminate
   - 功能描述:
     此API已存在，用于终止合同。当用户关闭“自动续签”时，前端将调用此接口。
   - 处理逻辑: 无需修改。该接口已经包含了修改合同状态、更新结束日期、删除多
     余账单和重算最后一期账单的逻辑。